<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>剑指 Offer 28-面试题 10.01</title>
    <link rel="stylesheet" href="../css/index.css">
</head>
<body>
<p class="orange">剑指 Offer 28. 对称的二叉树</p>
<script data-msg="剑指 Offer 28. 对称的二叉树">
    (() => {
        function isSymmetric(root, left, right){
            if (root === null) {
                return true;
            }
            if (left === undefined) {
                left = root.left;
            }
            if (right === undefined) {
                right = root.right;
            }
            //  值一样返回true
            if (left === null && right === null) {
                return true;
            }
            //  值只有一个null，返回false
            if (left === null || right === null) {
                return false;
            }
            if ((left && left.val) !== (right && right.val)) {
                return false;
            }
            return isSymmetric(root, left.right, right.left) && isSymmetric(root, left.left, right.right);
        }
    })();
</script>
<p>剑指 Offer 29. 顺时针打印矩阵</p>
<script data-msg="剑指 Offer 29. 顺时针打印矩阵">
    (() => {
        function spiralOrder(matrix){
            if (!matrix.length) {
                return matrix;
            }
            //  右，下，左，上
            const turnList = [1, 2, -1, -2];
            const rowLen = matrix.length;
            const colLen = matrix[0].length;
            const list = [];
            while (1) {
                for (let i = 0; i < turnList.length; i++) {
                    if (list.length === rowLen * colLen) {
                        return list;
                    }
                    switch (turnList[i]) {
                        case 1:
                            list.push(...matrix.splice(0, 1)[0]);
                            break;
                        case 2:
                            for (let i = 0; i < matrix.length; i++) {
                                list.push(matrix[i].splice(-1, 1)[0]);
                            }
                            break;
                        case -1:
                            list.push(...matrix.splice(-1, 1)[0].reverse());
                            break;
                        case -2:
                            for (let i = matrix.length - 1; i >= 0; i--) {
                                list.push(matrix[i].splice(0, 1)[0]);
                            }
                            break;
                    }
                }
            }
            return list;
        }

        const res = spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);
    })();
</script>
<p class="red">剑指 Offer 30. 包含min函数的栈</p>
<script data-msg="剑指 Offer 30. 包含min函数的栈">
    (() => {
        function MinStack(){
            this.list = [];
            this.sortList = [];
        }

        MinStack.prototype.push = function (x){
            this.list.push(x);
            if (this.sortList[this.sortList.length - 1] >= x || this.sortList.length === 0) {
                this.sortList.push(x);
            }
        };
        MinStack.prototype.pop = function (){
            const item = this.list.pop();
            if (this.sortList[this.sortList.length - 1] === item) {
                this.sortList.pop();
            }
            return item;
        };
        MinStack.prototype.min = function (){
            return this.sortList[this.sortList.length - 1];
        };
        MinStack.prototype.top = function (){
            return this.list[this.list.length - 1];
        };
        const minStack = new MinStack();
        minStack.push(-2);
        minStack.push(0);
        minStack.push(-3);
        minStack.min();
        minStack.pop();
        minStack.top();
        minStack.min();
    })();
</script>
<p>剑指 Offer 32 - II. 从上到下打印二叉树 II</p>
<script data-msg="剑指 Offer 32 - II. 从上到下打印二叉树 II">
    (() => {
        function levelOrder(root){
            const arr = [];
            if (!root) {
                return arr;
            }
            print(arr, root, 0);
            return arr;
        }

        function print(arr, node, nodeTier){
            if (node === null) {
                return;
            }
            arr[nodeTier] = arr[nodeTier] || [];
            arr[nodeTier].push(node.val);
            print(arr, node.left, nodeTier + 1);
            print(arr, node.right, nodeTier + 1);
        }
    })();
</script>
<p class="orange">剑指 Offer 39. 数组中出现次数超过一半的数字</p>
<script data-msg="剑指 Offer 39. 数组中出现次数超过一半的数字">
    (() => {
        //  摩尔计数法
        //  这个原理是，无论最多的多于一半的数分配到哪里，都能磨削掉理他最近的一个其他的数字
        function majorityElement(nums){
            let most = nums[0];
            let count = 1;
            for (let i = 1; i < nums.length; i++) {
                const current = nums[i];
                //  如果此前抵消了，就重新设置most，因为对于最后几个剩余的数，众数不会跑
                if (count === 0) {
                    most = current;
                }
                if (most === current) {
                    count++;
                } else {
                    count--;
                }
            }
            return most;
        }

        majorityElement([1, 2, 3, 2, 2, 2, 5, 4, 2]);
    })();
</script>
<p class="red">剑指 Offer 40. 最小的k个数</p>
<script data-msg="剑指 Offer 40. 最小的k个数">
    //  需要最小堆
    (() => {
        function getLeastNumbers(arr, k){
            if (k === 0 || arr.length === 0) {
                return [];
            }
            return arr.sort((a, b) => a - b).slice(0, k);
        }

        function getLeastNumbers(arr, k){
            if (k === 0 || arr.length === 0) {
                return [];
            }
            const list = arr.slice(0, k).sort((a, b) => a - b);
            for (let i = k; i < arr.length; i++) {
                const item = arr[i];
                let left = 0;
                let right = k - 1;
                if (item >= list[right]) {
                    continue;
                }
                while (left < right) {
                    if (item < list[left]) {
                        left = Math.floor((left + right) / 2);

                    }
                }
            }
            return list;
        }

        function getLeastNumbers(arr, k){

        }

        getLeastNumbers([3, 2, 1], 2);
    })();
</script>
<p class="red">剑指 Offer 42. 连续子数组的最大和</p>
<script data-msg="剑指 Offer 42. 连续子数组的最大和">
    (() => {
        //  point：前面的和>0?保留：取当前
        function maxSubArray(list){
            //  和，因为最少有一个
            let sum = list[0];
            //  历史最大，至少有一个
            let max = sum;
            for (let i = 1; i < list.length; i++) {
                const item = list[i];
                //  如果前面的和<0。可以抛弃了
                //  前面的和>0，所以+item，无论item是否大于零
                sum = item + (sum > 0 ? sum : 0);
                //  Math.max会判断sum是不是更大
                max = sum > max ? sum : max;
            }
            return max;
        }

        maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]);
    })();
</script>
<p>剑指 Offer 50. 第一个只出现一次的字符</p>
<script data-msg="剑指 Offer 50. 第一个只出现一次的字符">
    (() => {
        function firstUniqChar(s){
            const map = {};
            for (let value of s) {
                map[value] = map[value] === undefined;
            }
            for (let value of s) {
                if (map[value]) {
                    return value;
                }
            }
            return ' ';
        }

        firstUniqChar('leetcode');
    })();
</script>
<p class="red">剑指 Offer 52. 两个链表的第一个公共节点</p>
<script data-msg="剑指 Offer 52. 两个链表的第一个公共节点">
    (() => {
        //  headA+headB的最后几位 === headB+headA的最后几位
        function getIntersectionNode(headA, headB){
            let h1 = headA;
            let h2 = headB;
            while (h1 !== h2) {
                h1 = (h1 === null) ? headB : h1.next;
                h2 = (h2 === null) ? headA : h2.next;
            }
            return h1;
        }

        //  map有序
        function getIntersectionNode(headA, headB){
            const map = new Map();
            let h1 = headA;
            while (h1 !== null) {
                map.set(h1, 1);
                h1 = h1.next;
            }
            let h2 = headB;
            while (h2 !== null) {
                if (map.get(h2)) {
                    return h2;
                }
                h2 = h2.next;
            }
            return null;
        }
    })();
</script>
<p>剑指 Offer 53 - I. 在排序数组中查找数字 I</p>
<script data-msg="剑指 Offer 53 - I. 在排序数组中查找数字 I">
    (() => {
        function search(nums, target){
            if (nums.length === 0) {
                return 0;
            }
            let left = 0;
            let right = nums.length - 1;
            //  找到target
            let hasTarget = false;
            let sum = 0;
            let middle;
            while (left <= right) {
                middle = Math.floor((left + right) / 2);
                if (nums[middle] > target) {
                    right = middle - 1;
                } else if (nums[middle] < target) {
                    left = middle + 1;
                } else {
                    hasTarget = true;
                    break;
                }
            }

            if (hasTarget) {
                let left = -1;
                let right = 1;
                sum = 1;
                let preSum = 0;
                while (preSum !== sum) {
                    preSum = sum;
                    if (nums[middle + left] === target) {
                        sum++;
                        left--;
                    }
                    if (nums[middle + right] === target) {
                        sum++;
                        right++;
                    }
                }
            }
            return sum;
        }

        function search(nums, target){
            let left = 0;
            let right = nums.length - 1;
            //  找最小值，最小的left
            let middleIndex;
            while (left < right) {
                middleIndex = (left + right) >> 1;
                const current = nums[middleIndex];
                if (current > target) {
                    right = middleIndex - 1;
                } else if (current < target) {
                    left = middleIndex + 1;
                } else {
                    break;
                }
            }
            let sum = 0;
            for (let i = left; i <= right; i++) {
                if (nums[i] === target) {
                    sum++;
                }
            }
            return sum;
        }

    })();
</script>
<p>剑指 Offer 53 - II. 0～n-1中缺失的数字</p>
<script data-msg="剑指 Offer 53 - II. 0～n-1中缺失的数字">
    (() => {
        //  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        //  [0, 1, 3, 4, 5, 6, 7, 8, 9]     缺少2
        //  二分法，left就是
        function missingNumber(nums){
            let left = 0;
            let right = nums.length;
            while (left < right) {
                let middle = (left + right) >> 1;
                if (nums[middle] > middle) {
                    right = middle;
                } else if (nums[middle] === middle) {
                    left = middle + 1;
                }
            }
            return left;
        }

        missingNumber([0, 1, 3, 4, 5, 6, 7, 8, 9]);
    })();
</script>
<p>剑指 Offer 54. 二叉搜索树的第k大节点</p>
<script data-msg="剑指 Offer 54. 二叉搜索树的第k大节点">
    (() => {
        //  从右到左深度遍历
        //  在k有优化
        function kthLargest(root, k){
            const arr = [];
            arr.k = k;
            getValue(root, arr);
            return arr[k - 1];
        }

        function getValue(node, arr){
            if (node === null) {
                return;
            }
            getValue(node.right, arr);
            arr.push(node.val);
            //  优化
            arr.k--;
            if (arr.k === 0) {
                return;
            }
            getValue(node.left, arr);
        }
    })();
</script>
<p class="orange">剑指 Offer 55 - I. 二叉树的深度</p>
<script data-msg="剑指 Offer 55 - I. 二叉树的深度">
    (() => {
        function maxDepth(root){
            const childrenList = [];
            getTier(root, childrenList, 0);
            return childrenList.length;
        }

        function getTier(node, childrenList, tier){
            if (node === null) {
                return;
            }
            childrenList[tier] = childrenList[tier] || [];
            childrenList[tier].push(node);
            getTier(node.left, childrenList, tier + 1);
            getTier(node.right, childrenList, tier + 1);
        }

        function maxDepth(root, max = 0){
            if (root === null) {
                return max;
            }
            const left = getTier(root.left, max);
            const right = getTier(root.right, max);
            return Math.max(left, right) + 1;
        }

    })();
</script>
<p>剑指 Offer 55 - II. 平衡二叉树</p>
<script data-msg="剑指 Offer 55 - II. 平衡二叉树">
    (() => {
        //  [1, null, 2, null, 3];

        function isBalanced(root){
            if (root === null) {
                return true;
            }
            return getTier(root);
        }

        function getTier(root, tier = 0){
            if (root === null) {
                return tier;
            }
            let left = getTier(root.left, tier);
            let right = getTier(root.right, tier);
            if (left === false || right === false) {
                return false;
            }
            if (Math.abs(left - right) > 1) {
                return false;
            }
            return Math.max(left, right) + 1;
        }
    })();
</script>
<p class="orange">剑指 Offer 57. 和为s的两个数字</p>
<script data-msg="剑指 Offer 57. 和为s的两个数字">
    (() => {
        //  [2,7,11,15]
        //  9

        //  map法
        function twoSum(nums, target){
            const map = {};
            for (let value of nums) {
                if (map[value]) {
                    return [value, target - value];
                }
                map[target - value] = 1;
            }
        }

        //  双指针，有序所以可以双指针
        function twoSum(nums, target){
            let left = 0;
            let right = nums.length - 1;
            let sum = nums[left] + nums[right];
            while (sum !== target) {
                if (sum > target) {
                    right--;
                } else if (sum < target) {
                    left++;
                }
                sum = nums[left] + nums[right];
            }
            return [nums[left], nums[right]];
        }

    })();
</script>
<p class="red">剑指 Offer 57 - II. 和为s的连续正数序列</p>
<script data-msg="剑指 Offer 57 - II. 和为s的连续正数序列">
    (() => {
        function findContinuousSequence(target){
            const res = [];
            //  最大这个数
            let len = ((target - 1) >> 1) + 2;
            //  从1开始
            for (let i = 1; i < len; i++) {
                let current = [];
                let j = i;
                let sum = j;
                while (sum < target) {
                    sum = and(i, j, (j - i + 1));
                    current.push(j);
                    j++;
                }
                if (sum === target) {
                    res.push(current);
                }
            }
            return res;
        }

        function and(f, l, n){
            return (f + l) * n / 2;
        }

        //   todo    还有更好的

    })();
</script>
<p>剑指 Offer 58 - I. 翻转单词顺序</p>
<script data-msg="剑指 Offer 58 - I. 翻转单词顺序">
    (() => {
        function reverseWords(s){
            s = s.trim();
            const list = [];
            const sList = s.split(' ');
            for (let i = sList.length - 1; i >= 0; i--) {
                const item = sList[i].trim();
                if (item === '') {
                    continue;
                }
                list.push(item);
            }
            return list.join(' ');
        }

        function reverseWords(s){
            s = s.trim().replace(/\s+/ig, ' ');
            return s.split(' ').reverse().join(' ');
        }
    })();
</script>
<p>剑指 Offer 58 - II. 左旋转字符串</p>
<script data-msg="剑指 Offer 58 - II. 左旋转字符串">
    (() => {
        function reverseLeftWords(s, n){
            n = n % s.length;
            return s.slice(n) + s.slice(0, n);
        }
    })();
</script>
<p class="red">剑指 Offer 59 - I. 滑动窗口的最大值</p>
<script data-msg="剑指 Offer 59 - I. 滑动窗口的最大值">
    (() => {
        //  需要维护单调队列
        function maxSlidingWindow(nums, k){
            if (nums.length === 0) {
                return nums;
            }
            //  滑动窗口
//            let slide = nums.slice(0, k);
            //  单调队列，升序
            const list = nums.slice(0, k).sort((a, b) => a - b);
            //  返回值
            const resultArray = [];
            let i = 0;
            while (true) {
                //  先装
                resultArray.push(list[list.length - 1]);
                //  删除第一个
                const index = nums[i];
                //  队列里删除第一个
                list.splice(list.indexOf(index), 1);
                //  二分
                let left = 0;
                let right = list.length - 1;
                //  新增的值
                const newValue = nums[k + i];
                if (newValue === undefined) {
                    break;
                }
                while (left <= right) {
                    const middle = (left + right) >> 1;
                    const middleValue = list[middle];
                    if (middleValue > newValue) {
                        right = middle - 1;
                    } else if (middleValue < newValue) {
                        left = middle + 1;
                    } else {
                        left = middle;
                        break;
                    }
                }
                //  新增值
                list.splice(right, 0, newValue);
                i++;
            }

            return resultArray;
        }

        maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3);

    })();
</script>
<p class="red">剑指 Offer 60. n个骰子的点数</p>
<script data-msg="剑指 Offer 60. n个骰子的点数">
    (() => {
        //  排列组合
        function twoSum(n){
            const total = Math.pow(6, n);
            const type = [1, 2, 3, 4, 5, 6];
            const res = [];
            const map = {
                1: 0,
                2: 0,
                3: 0,
                4: 0,
                5: 0,
                6: 0,
            };
            while (n--) {
                const temp = [];
                for (let value of type) {
                    for (let _value of res) {
                        const key = value + _value;
                        temp.push(key);
                        map[key] = map[key] || 0;
                        map[key]++;
                    }
                }

            }
        }
    })();
</script>
<p>剑指 Offer 61. 扑克牌中的顺子</p>
<script data-msg="剑指 Offer 61. 扑克牌中的顺子">
    (() => {
        function isStraight(list){
            let min;
            let max;
            const map = {};
            for (const item of list) {
                if (item === 0) {
                    continue;
                }
                //  重复
                if (map[item]) {
                    return false;
                }
                map[item] = 1;
                //  初始值
                if (min === undefined) {
                    min = item;
                    max = item;
                    continue;
                }
                //  更小
                if (min > item) {
                    min = item;
                    continue;
                }
                //  更大
                if (max < item) {
                    max = item;
                }
            }
            return (max - min < 5);
        }

        isStraight([0, 0, 2, 2, 5]);
    })();
</script>
<p class="red">剑指 Offer 62. 圆圈中最后剩下的数字</p>
<script data-msg="剑指 Offer 62. 圆圈中最后剩下的数字">
    (() => {
        return;

        //  我日
        function lastRemaining(n, m){
            let x = 0;
            let i = 1;
            while (i <= n) {
                x = (x + m) % i;
                i++;
            }
            return x;
        }

//        debugger
        const res = lastRemaining(5, 3);
        console.log(res);
        //  0、1、2、3、4
        //  1
        //  0、1、2、3     4
        //  2
        //  1、3、0、4     2
        //  3
        //  2、0、4、1     3
        //  4
        //  3、2、4、1     0
        //  5
        //  4、0、2、3     1

        //  0、1、2、3
        //  1
        //  0、1、2       3
        //  2
        //  1、3、2       0
        //  3
        //  2、3、0       2
        //  4
        //  3、0、2       1

        //  0、1、2
        //  1
        //  0、1         2
        //  2
        //  1、0         2
        //  3
        //  2、0         1

    })();
</script>
<p class="red">剑指 Offer 65. 不用加减乘除做加法</p>
<script data-msg="剑指 Offer 65. 不用加减乘除做加法">
    (() => {
        //  看解题
        function add(a, b){
            while (b !== 0) {
                const c = (a&b) << 1;  // c = 进位
                a ^= b; // a = 非进位和
                b = c; // b = 进位
            }
            return a;
        }

        add(1, 2);
    })();
</script>
<p>剑指 Offer 66. 构建乘积数组</p>
<script data-msg="剑指 Offer 66. 构建乘积数组">
    (() => {
        function constructArr(a){
            if (a.length === 0) {
                return a;
            }
            const b = [];

            for (let i = 0; i < a.length; i++) {
                let item = a[i - 1];
                item = item === undefined ? 1 : item;
                b[i] = item * (b[i - 1] === undefined ? 1 : b[i - 1]);
            }
            let sum = 1;
            for (let i = a.length - 1; i >= 0; i--) {
                let item = a[i + 1];
                item = item === undefined ? 1 : item;
                sum *= item;
                b[i] = sum * b[i];
            }

            return b;
        }

        constructArr([1, 2, 3, 4, 5]);

    })();
</script>
<p class="red">面试题 01.01. 判定字符是否唯一</p>
<script data-msg="面试题 01.01. 判定字符是否唯一">
    (() => {
        //  ✅✅✅✅
        //  按位运算存值，原理相当于字符串存值 '00001' -> '00010'
        //  按位将1左移几位，就变成了 '01几个零'，这样的二进制数
        //  移动a位和b位，他们是肯定不会重复的，所以如果mark的值为 '0110' 时，说明分别有过2和1，也就是出现了 c和b
        //  然后按位与，如果新出来一个c，左移动3位后，是 '0100'，与一下 '0110'就不为 0，说明c重复了
        /**
         * @param {string} astr
         * @return {boolean}
         */
        function isUnique(astr){
            //  用位运算保存
            let mark = 0;
            for (let value of astr) {
                const index = value.charCodeAt(0) - 97;
                //  左移动几位
                const left = 1 << index;
                if ((mark&left) !== 0) {
                    //  重复
                    return false;
                }
                mark = mark|left;
            }
            return true;
        }

        isUnique('bcdb'.toLowerCase());
    })();
</script>
<p>面试题 01.02. 判定是否互为字符重排</p>
<script data-msg="面试题 01.02. 判定是否互为字符重排">
    (() => {
        function CheckPermutation(s1, s2){
            if (s1.length !== s2.length) {
                return false;
            }
            const map = {};
            for (let value of s1) {
                map[value] = map[value] || 0;
                map[value]++;
            }
            for (let value of s2) {
                if (map[value] === undefined || map[value] === 0) {
                    return false;
                }
                map[value]--;
            }
            return true;
        }

    })();
</script>
</body>
</html>
<script>
    (() => {
        return;
        const jichugongjili = 4042 + 300 + 5300;
        console.log('基础攻击力', jichugongjili);
        const changzhuyisu = (19.8 * 2 + 14.9 + 67.5) / 100;
        console.log('常驻移速', changzhuyisu);
        const weidagongjili = 1.34;
        const kauichegongjili = (jichugongjili * (1 + changzhuyisu * 1.23) * weidagongjili).toFixed(2);
        console.log('快车攻击力', kauichegongjili);
        const yumiyijineng = 1.45;
        const yumierjinenggongjili = Math.min((kauichegongjili * (1 + changzhuyisu) * yumiyijineng), 80000);
        console.log('玉米二技能攻击力', yumierjinenggongjili);
        const yumierjineng = (yumierjinenggongjili / 100 * 0.046).toFixed(2);
        console.log('玉米二技能', yumierjineng);
        //
        const zongshanghai = (yumierjineng * kauichegongjili * 4.22).toFixed(2);
        console.log('总伤害', zongshanghai);
    })();
</script>






