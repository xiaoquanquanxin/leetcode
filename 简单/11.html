<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>剑指 Offer 28-面试题 10.01</title>
    <link rel="stylesheet" href="../css/index.css">
</head>
<body>
<p class="orange">剑指 Offer 28. 对称的二叉树</p>
<script data-msg="剑指 Offer 28. 对称的二叉树">
    (() => {
        function isSymmetric(root, left, right){
            if (root === null) {
                return true;
            }
            if (left === undefined) {
                left = root.left;
            }
            if (right === undefined) {
                right = root.right;
            }
            //  值一样返回true
            if (left === null && right === null) {
                return true;
            }
            //  值只有一个null，返回false
            if (left === null || right === null) {
                return false;
            }
            if ((left && left.val) !== (right && right.val)) {
                return false;
            }
            return isSymmetric(root, left.right, right.left) && isSymmetric(root, left.left, right.right);
        }
    })();
</script>
<p>剑指 Offer 29. 顺时针打印矩阵</p>
<script data-msg="剑指 Offer 29. 顺时针打印矩阵">
    (() => {
        function spiralOrder(matrix){
            if (!matrix.length) {
                return matrix;
            }
            //  右，下，左，上
            const turnList = [1, 2, -1, -2];
            const rowLen = matrix.length;
            const colLen = matrix[0].length;
            const list = [];
            while (1) {
                for (let i = 0; i < turnList.length; i++) {
                    if (list.length === rowLen * colLen) {
                        return list;
                    }
                    switch (turnList[i]) {
                        case 1:
                            list.push(...matrix.splice(0, 1)[0]);
                            break;
                        case 2:
                            for (let i = 0; i < matrix.length; i++) {
                                list.push(matrix[i].splice(-1, 1)[0]);
                            }
                            break;
                        case -1:
                            list.push(...matrix.splice(-1, 1)[0].reverse());
                            break;
                        case -2:
                            for (let i = matrix.length - 1; i >= 0; i--) {
                                list.push(matrix[i].splice(0, 1)[0]);
                            }
                            break;
                    }
                }
            }
            return list;
        }

        const res = spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);
    })();
</script>
<p class="red">剑指 Offer 30. 包含min函数的栈</p>
<script data-msg="剑指 Offer 30. 包含min函数的栈">
    (() => {
        function MinStack(){
            this.list = [];
            this.sortList = [];
        }

        MinStack.prototype.push = function (x){
            this.list.push(x);
            if (this.sortList[this.sortList.length - 1] >= x || this.sortList.length === 0) {
                this.sortList.push(x);
            }
        };
        MinStack.prototype.pop = function (){
            const item = this.list.pop();
            if (this.sortList[this.sortList.length - 1] === item) {
                this.sortList.pop();
            }
            return item;
        };
        MinStack.prototype.min = function (){
            return this.sortList[this.sortList.length - 1];
        };
        MinStack.prototype.top = function (){
            return this.list[this.list.length - 1];
        };
        const minStack = new MinStack();
        minStack.push(-2);
        minStack.push(0);
        minStack.push(-3);
        minStack.min();
        minStack.pop();
        minStack.top();
        minStack.min();
    })();
</script>
<p>剑指 Offer 32 - II. 从上到下打印二叉树 II</p>
<script data-msg="剑指 Offer 32 - II. 从上到下打印二叉树 II">
    (() => {
        function levelOrder(root){
            const arr = [];
            if (!root) {
                return arr;
            }
            print(arr, root, 0);
            return arr;
        }

        function print(arr, node, nodeTier){
            if (node === null) {
                return;
            }
            arr[nodeTier] = arr[nodeTier] || [];
            arr[nodeTier].push(node.val);
            print(arr, node.left, nodeTier + 1);
            print(arr, node.right, nodeTier + 1);
        }
    })();
</script>
<p class="orange">剑指 Offer 39. 数组中出现次数超过一半的数字</p>
<script data-msg="剑指 Offer 39. 数组中出现次数超过一半的数字">
    (() => {
        //  摩尔计数法
        //  这个原理是，无论最多的多于一半的数分配到哪里，都能磨削掉理他最近的一个其他的数字
        function majorityElement(nums){
            let most = nums[0];
            let count = 1;
            for (let i = 1; i < nums.length; i++) {
                const current = nums[i];
                //  如果此前抵消了，就重新设置most，因为对于最后几个剩余的数，众数不会跑
                if (count === 0) {
                    most = current;
                }
                if (most === current) {
                    count++;
                } else {
                    count--;
                }
            }
            return most;
        }

        majorityElement([1, 2, 3, 2, 2, 2, 5, 4, 2]);
    })();
</script>
<p class="red">剑指 Offer 40. 最小的k个数</p>
<script data-msg="剑指 Offer 40. 最小的k个数">
    //  需要最小堆
    (() => {
        function getLeastNumbers(arr, k){
            if (k === 0 || arr.length === 0) {
                return [];
            }
            return arr.sort((a, b) => a - b).slice(0, k);
        }

        function getLeastNumbers(arr, k){
            if (k === 0 || arr.length === 0) {
                return [];
            }
            const list = arr.slice(0, k).sort((a, b) => a - b);
            for (let i = k; i < arr.length; i++) {
                const item = arr[i];
                let left = 0;
                let right = k - 1;
                if (item >= list[right]) {
                    continue;
                }
                while (left < right) {
                    if (item < list[left]) {
                        left = Math.floor((left + right) / 2);

                    }
                }
            }
            return list;
        }

        function getLeastNumbers(arr, k){

        }

        getLeastNumbers([3, 2, 1], 2);
    })();
</script>
<p class="red">剑指 Offer 42. 连续子数组的最大和</p>
<script data-msg="剑指 Offer 42. 连续子数组的最大和">
    (() => {
        //  point：前面的和>0?保留：取当前
        function maxSubArray(list){
            //  和，因为最少有一个
            let sum = list[0];
            //  历史最大，至少有一个
            let max = sum;
            for (let i = 1; i < list.length; i++) {
                const item = list[i];
                //  如果前面的和<0。可以抛弃了
                //  前面的和>0，所以+item，无论item是否大于零
                sum = item + (sum > 0 ? sum : 0);
                //  Math.max会判断sum是不是更大
                max = sum > max ? sum : max;
            }
            return max;
        }

        maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]);
    })();
</script>
<p>剑指 Offer 50. 第一个只出现一次的字符</p>
<script data-msg="剑指 Offer 50. 第一个只出现一次的字符">
    (() => {
        function firstUniqChar(s){
            const map = {};
            for (let value of s) {
                map[value] = map[value] === undefined;
            }
            for (let value of s) {
                if (map[value]) {
                    return value;
                }
            }
            return ' ';
        }

        firstUniqChar('leetcode');
    })();
</script>
<p class="red">剑指 Offer 52. 两个链表的第一个公共节点</p>
<script data-msg="剑指 Offer 52. 两个链表的第一个公共节点">
    (() => {
        //  headA+headB的最后几位 === headB+headA的最后几位
        function getIntersectionNode(headA, headB){
            let h1 = headA;
            let h2 = headB;
            while (h1 !== h2) {
                h1 = (h1 === null) ? headB : h1.next;
                h2 = (h2 === null) ? headA : h2.next;
            }
            return h1;
        }

        //  map有序
        function getIntersectionNode(headA, headB){
            const map = new Map();
            let h1 = headA;
            while (h1 !== null) {
                map.set(h1, 1);
                h1 = h1.next;
            }
            let h2 = headB;
            while (h2 !== null) {
                if (map.get(h2)) {
                    return h2;
                }
                h2 = h2.next;
            }
            return null;
        }
    })();
</script>
<p>剑指 Offer 53 - I. 在排序数组中查找数字 I</p>
<script data-msg="剑指 Offer 53 - I. 在排序数组中查找数字 I">
    (() => {
        function search(nums, target){
            if (nums.length === 0) {
                return 0;
            }
            let left = 0;
            let right = nums.length - 1;
            //  找到target
            let hasTarget = false;
            let sum = 0;
            let middle;
            while (left <= right) {
                middle = Math.floor((left + right) / 2);
                if (nums[middle] > target) {
                    right = middle - 1;
                } else if (nums[middle] < target) {
                    left = middle + 1;
                } else {
                    hasTarget = true;
                    break;
                }
            }

            if (hasTarget) {
                let left = -1;
                let right = 1;
                sum = 1;
                let preSum = 0;
                while (preSum !== sum) {
                    preSum = sum;
                    if (nums[middle + left] === target) {
                        sum++;
                        left--;
                    }
                    if (nums[middle + right] === target) {
                        sum++;
                        right++;
                    }
                }
            }
            return sum;
        }

        function search(nums, target){
            let left = 0;
            let right = nums.length - 1;
            //  找最小值，最小的left
            let middleIndex;
            while (left < right) {
                middleIndex = (left + right) >> 1;
                const current = nums[middleIndex];
                if (current > target) {
                    right = middleIndex - 1;
                } else if (current < target) {
                    left = middleIndex + 1;
                } else {
                    break;
                }
            }
            let sum = 0;
            for (let i = left; i <= right; i++) {
                if (nums[i] === target) {
                    sum++;
                }
            }
            return sum;
        }

    })();
</script>
<p>剑指 Offer 53 - II. 0～n-1中缺失的数字</p>
<script data-msg="剑指 Offer 53 - II. 0～n-1中缺失的数字">
    (() => {
        //  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        //  [0, 1, 3, 4, 5, 6, 7, 8, 9]     缺少2
        //  二分法，left就是
        function missingNumber(nums){
            let left = 0;
            let right = nums.length;
            while (left < right) {
                let middle = (left + right) >> 1;
                if (nums[middle] > middle) {
                    right = middle;
                } else if (nums[middle] === middle) {
                    left = middle + 1;
                }
            }
            return left;
        }

        missingNumber([0, 1, 3, 4, 5, 6, 7, 8, 9]);
    })();
</script>
<p>剑指 Offer 54. 二叉搜索树的第k大节点</p>
<script data-msg="剑指 Offer 54. 二叉搜索树的第k大节点">
    (() => {

    })();
</script>
</body>
</html>
<script>
    (() => {
        return;
        const jichugongjili = 4042 + 300 + 5300;
        console.log('基础攻击力', jichugongjili);
        const changzhuyisu = (19.8 * 2 + 14.9 + 67.5) / 100;
        console.log('常驻移速', changzhuyisu);
        const weidagongjili = 1.34;
        const kauichegongjili = (jichugongjili * (1 + changzhuyisu * 1.23) * weidagongjili).toFixed(2);
        console.log('快车攻击力', kauichegongjili);
        const yumiyijineng = 1.45;
        const yumierjinenggongjili = Math.min((kauichegongjili * (1 + changzhuyisu) * yumiyijineng), 80000);
        console.log('玉米二技能攻击力', yumierjinenggongjili);
        const yumierjineng = (yumierjinenggongjili / 100 * 0.046).toFixed(2);
        console.log('玉米二技能', yumierjineng);
        //
        const zongshanghai = (yumierjineng * kauichegongjili * 4.22).toFixed(2);
        console.log('总伤害', zongshanghai);
    })();
</script>






