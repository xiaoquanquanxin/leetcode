<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>剑指 Offer 28-面试题 10.01</title>
    <link rel="stylesheet" href="../css/index.css">
</head>
<body>
<p class="orange">剑指 Offer 28. 对称的二叉树</p>
<script data-msg="剑指 Offer 28. 对称的二叉树">
    (() => {
        function isSymmetric(root, left, right){
            if (root === null) {
                return true;
            }
            if (left === undefined) {
                left = root.left;
            }
            if (right === undefined) {
                right = root.right;
            }
            //  值一样返回true
            if (left === null && right === null) {
                return true;
            }
            //  值只有一个null，返回false
            if (left === null || right === null) {
                return false;
            }
            if ((left && left.val) !== (right && right.val)) {
                return false;
            }
            return isSymmetric(root, left.right, right.left) && isSymmetric(root, left.left, right.right);
        }
    })();
</script>
<p>剑指 Offer 29. 顺时针打印矩阵</p>
<script data-msg="剑指 Offer 29. 顺时针打印矩阵">
    (() => {
        function spiralOrder(matrix){
            if (!matrix.length) {
                return matrix;
            }
            //  右，下，左，上
            const turnList = [1, 2, -1, -2];
            const rowLen = matrix.length;
            const colLen = matrix[0].length;
            const list = [];
            while (1) {
                for (let i = 0; i < turnList.length; i++) {
                    if (list.length === rowLen * colLen) {
                        return list;
                    }
                    switch (turnList[i]) {
                        case 1:
                            list.push(...matrix.splice(0, 1)[0]);
                            break;
                        case 2:
                            for (let i = 0; i < matrix.length; i++) {
                                list.push(matrix[i].splice(-1, 1)[0]);
                            }
                            break;
                        case -1:
                            list.push(...matrix.splice(-1, 1)[0].reverse());
                            break;
                        case -2:
                            for (let i = matrix.length - 1; i >= 0; i--) {
                                list.push(matrix[i].splice(0, 1)[0]);
                            }
                            break;
                    }
                }
            }
            return list;
        }

        const res = spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);
    })();
</script>
<p class="red">剑指 Offer 30. 包含min函数的栈</p>
<script data-msg="剑指 Offer 30. 包含min函数的栈">
    (() => {
        function MinStack(){
            this.list = [];
            this.sortList = [];
        }

        MinStack.prototype.push = function (x){
            this.list.push(x);
            if (this.sortList[this.sortList.length - 1] >= x || this.sortList.length === 0) {
                this.sortList.push(x);
            }
        };
        MinStack.prototype.pop = function (){
            const item = this.list.pop();
            if (this.sortList[this.sortList.length - 1] === item) {
                this.sortList.pop();
            }
            return item;
        };
        MinStack.prototype.min = function (){
            return this.sortList[this.sortList.length - 1];
        };
        MinStack.prototype.top = function (){
            return this.list[this.list.length - 1];
        };
        const minStack = new MinStack();
        minStack.push(-2);
        minStack.push(0);
        minStack.push(-3);
        minStack.min();
        minStack.pop();
        minStack.top();
        minStack.min();
    })();
</script>
<p>剑指 Offer 32 - II. 从上到下打印二叉树 II</p>
<script data-msg="剑指 Offer 32 - II. 从上到下打印二叉树 II">
    (() => {
        function levelOrder(root){
            const arr = [];
            if (!root) {
                return arr;
            }
            print(arr, root, 0);
            return arr;
        }

        function print(arr, node, nodeTier){
            if (node === null) {
                return;
            }
            arr[nodeTier] = arr[nodeTier] || [];
            arr[nodeTier].push(node.val);
            print(arr, node.left, nodeTier + 1);
            print(arr, node.right, nodeTier + 1);
        }
    })();
</script>
<p class="orange">剑指 Offer 39. 数组中出现次数超过一半的数字</p>
<script data-msg="剑指 Offer 39. 数组中出现次数超过一半的数字">
    (() => {
        //  摩尔计数法
        //  这个原理是，无论最多的多于一半的数分配到哪里，都能磨削掉理他最近的一个其他的数字
        function majorityElement(nums){
            let most = nums[0];
            let count = 1;
            for (let i = 1; i < nums.length; i++) {
                const current = nums[i];
                //  如果此前抵消了，就重新设置most，因为对于最后几个剩余的数，众数不会跑
                if (count === 0) {
                    most = current;
                }
                if (most === current) {
                    count++;
                } else {
                    count--;
                }
            }
            return most;
        }

        majorityElement([1, 2, 3, 2, 2, 2, 5, 4, 2]);
    })();
</script>
<p class="red">剑指 Offer 40. 最小的k个数</p>
<script data-msg="剑指 Offer 40. 最小的k个数">
    //  需要最小堆
    (() => {
        function getLeastNumbers(arr, k){
            if (k === 0 || arr.length === 0) {
                return [];
            }
            return arr.sort((a, b) => a - b).slice(0, k);
        }

        function getLeastNumbers(arr, k){
            if (k === 0 || arr.length === 0) {
                return [];
            }
            const list = arr.slice(0, k).sort((a, b) => a - b);
            for (let i = k; i < arr.length; i++) {
                const item = arr[i];
                let left = 0;
                let right = k - 1;
                if (item >= list[right]) {
                    continue;
                }
                while (left < right) {
                    if (item < list[left]) {
                        left = Math.floor((left + right) / 2);

                    }
                }
            }
            return list;
        }

        function getLeastNumbers(arr, k){

        }

        getLeastNumbers([3, 2, 1], 2);
    })();
</script>
<p class="red">剑指 Offer 42. 连续子数组的最大和</p>
<script data-msg="剑指 Offer 42. 连续子数组的最大和">
    (() => {
        //  point：前面的和>0?保留：取当前
        function maxSubArray(list){
            //  和，因为最少有一个
            let sum = list[0];
            //  历史最大，至少有一个
            let max = sum;
            for (let i = 1; i < list.length; i++) {
                const item = list[i];
                //  如果前面的和<0。可以抛弃了
                //  前面的和>0，所以+item，无论item是否大于零
                sum = item + (sum > 0 ? sum : 0);
                //  Math.max会判断sum是不是更大
                max = sum > max ? sum : max;
            }
            return max;
        }

        maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]);
    })();
</script>
<p>剑指 Offer 50. 第一个只出现一次的字符</p>
<script data-msg="剑指 Offer 50. 第一个只出现一次的字符">
    (() => {
        function firstUniqChar(s){
            const map = {};
            for (let value of s) {
                map[value] = map[value] === undefined;
            }
            for (let value of s) {
                if (map[value]) {
                    return value;
                }
            }
            return ' ';
        }

        firstUniqChar('leetcode');
    })();
</script>
<p class="red">剑指 Offer 52. 两个链表的第一个公共节点</p>
<script data-msg="剑指 Offer 52. 两个链表的第一个公共节点">
    (() => {
        //  headA+headB的最后几位 === headB+headA的最后几位
        function getIntersectionNode(headA, headB){
            let h1 = headA;
            let h2 = headB;
            while (h1 !== h2) {
                h1 = (h1 === null) ? headB : h1.next;
                h2 = (h2 === null) ? headA : h2.next;
            }
            return h1;
        }

        //  map有序
        function getIntersectionNode(headA, headB){
            const map = new Map();
            let h1 = headA;
            while (h1 !== null) {
                map.set(h1, 1);
                h1 = h1.next;
            }
            let h2 = headB;
            while (h2 !== null) {
                if (map.get(h2)) {
                    return h2;
                }
                h2 = h2.next;
            }
            return null;
        }
    })();
</script>
<p>剑指 Offer 53 - I. 在排序数组中查找数字 I</p>
<script data-msg="剑指 Offer 53 - I. 在排序数组中查找数字 I">
    (() => {
        function search(nums, target){
            if (nums.length === 0) {
                return 0;
            }
            let left = 0;
            let right = nums.length - 1;
            //  找到target
            let hasTarget = false;
            let sum = 0;
            let middle;
            while (left <= right) {
                middle = Math.floor((left + right) / 2);
                if (nums[middle] > target) {
                    right = middle - 1;
                } else if (nums[middle] < target) {
                    left = middle + 1;
                } else {
                    hasTarget = true;
                    break;
                }
            }

            if (hasTarget) {
                let left = -1;
                let right = 1;
                sum = 1;
                let preSum = 0;
                while (preSum !== sum) {
                    preSum = sum;
                    if (nums[middle + left] === target) {
                        sum++;
                        left--;
                    }
                    if (nums[middle + right] === target) {
                        sum++;
                        right++;
                    }
                }
            }
            return sum;
        }

        function search(nums, target){
            let left = 0;
            let right = nums.length - 1;
            //  找最小值，最小的left
            let middleIndex;
            while (left < right) {
                middleIndex = (left + right) >> 1;
                const current = nums[middleIndex];
                if (current > target) {
                    right = middleIndex - 1;
                } else if (current < target) {
                    left = middleIndex + 1;
                } else {
                    break;
                }
            }
            let sum = 0;
            for (let i = left; i <= right; i++) {
                if (nums[i] === target) {
                    sum++;
                }
            }
            return sum;
        }

    })();
</script>
<p>剑指 Offer 53 - II. 0～n-1中缺失的数字</p>
<script data-msg="剑指 Offer 53 - II. 0～n-1中缺失的数字">
    (() => {
        //  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        //  [0, 1, 3, 4, 5, 6, 7, 8, 9]     缺少2
        //  二分法，left就是
        function missingNumber(nums){
            let left = 0;
            let right = nums.length;
            while (left < right) {
                let middle = (left + right) >> 1;
                if (nums[middle] > middle) {
                    right = middle;
                } else if (nums[middle] === middle) {
                    left = middle + 1;
                }
            }
            return left;
        }

        missingNumber([0, 1, 3, 4, 5, 6, 7, 8, 9]);
    })();
</script>
<p>剑指 Offer 54. 二叉搜索树的第k大节点</p>
<script data-msg="剑指 Offer 54. 二叉搜索树的第k大节点">
    (() => {
        //  从右到左深度遍历
        //  在k有优化
        function kthLargest(root, k){
            const arr = [];
            arr.k = k;
            getValue(root, arr);
            return arr[k - 1];
        }

        function getValue(node, arr){
            if (node === null) {
                return;
            }
            getValue(node.right, arr);
            arr.push(node.val);
            //  优化
            arr.k--;
            if (arr.k === 0) {
                return;
            }
            getValue(node.left, arr);
        }
    })();
</script>
<p class="orange">剑指 Offer 55 - I. 二叉树的深度</p>
<script data-msg="剑指 Offer 55 - I. 二叉树的深度">
    (() => {
        function maxDepth(root){
            const childrenList = [];
            getTier(root, childrenList, 0);
            return childrenList.length;
        }

        function getTier(node, childrenList, tier){
            if (node === null) {
                return;
            }
            childrenList[tier] = childrenList[tier] || [];
            childrenList[tier].push(node);
            getTier(node.left, childrenList, tier + 1);
            getTier(node.right, childrenList, tier + 1);
        }

        function maxDepth(root, max = 0){
            if (root === null) {
                return max;
            }
            const left = getTier(root.left, max);
            const right = getTier(root.right, max);
            return Math.max(left, right) + 1;
        }

    })();
</script>
<p>剑指 Offer 55 - II. 平衡二叉树</p>
<script data-msg="剑指 Offer 55 - II. 平衡二叉树">
    (() => {
        //  [1, null, 2, null, 3];

        function isBalanced(root){
            if (root === null) {
                return true;
            }
            return getTier(root);
        }

        function getTier(root, tier = 0){
            if (root === null) {
                return tier;
            }
            let left = getTier(root.left, tier);
            let right = getTier(root.right, tier);
            if (left === false || right === false) {
                return false;
            }
            if (Math.abs(left - right) > 1) {
                return false;
            }
            return Math.max(left, right) + 1;
        }
    })();
</script>
<p class="orange">剑指 Offer 57. 和为s的两个数字</p>
<script data-msg="剑指 Offer 57. 和为s的两个数字">
    (() => {
        //  [2,7,11,15]
        //  9

        //  map法
        function twoSum(nums, target){
            const map = {};
            for (let value of nums) {
                if (map[value]) {
                    return [value, target - value];
                }
                map[target - value] = 1;
            }
        }

        //  双指针，有序所以可以双指针
        function twoSum(nums, target){
            let left = 0;
            let right = nums.length - 1;
            let sum = nums[left] + nums[right];
            while (sum !== target) {
                if (sum > target) {
                    right--;
                } else if (sum < target) {
                    left++;
                }
                sum = nums[left] + nums[right];
            }
            return [nums[left], nums[right]];
        }

    })();
</script>
<p class="red">剑指 Offer 57 - II. 和为s的连续正数序列</p>
<script data-msg="剑指 Offer 57 - II. 和为s的连续正数序列">
    (() => {
        function findContinuousSequence(target){
            const res = [];
            //  最大这个数
            let len = ((target - 1) >> 1) + 2;
            //  从1开始
            for (let i = 1; i < len; i++) {
                let current = [];
                let j = i;
                let sum = j;
                while (sum < target) {
                    sum = and(i, j, (j - i + 1));
                    current.push(j);
                    j++;
                }
                if (sum === target) {
                    res.push(current);
                }
            }
            return res;
        }

        function and(f, l, n){
            return (f + l) * n / 2;
        }

        //   todo    还有更好的

    })();
</script>
<p>剑指 Offer 58 - I. 翻转单词顺序</p>
<script data-msg="剑指 Offer 58 - I. 翻转单词顺序">
    (() => {
        function reverseWords(s){
            s = s.trim();
            const list = [];
            const sList = s.split(' ');
            for (let i = sList.length - 1; i >= 0; i--) {
                const item = sList[i].trim();
                if (item === '') {
                    continue;
                }
                list.push(item);
            }
            return list.join(' ');
        }

        function reverseWords(s){
            s = s.trim().replace(/\s+/ig, ' ');
            return s.split(' ').reverse().join(' ');
        }
    })();
</script>
<p>剑指 Offer 58 - II. 左旋转字符串</p>
<script data-msg="剑指 Offer 58 - II. 左旋转字符串">
    (() => {
        function reverseLeftWords(s, n){
            n = n % s.length;
            return s.slice(n) + s.slice(0, n);
        }
    })();
</script>
<p class="red">剑指 Offer 59 - I. 滑动窗口的最大值</p>
<script data-msg="剑指 Offer 59 - I. 滑动窗口的最大值">
    (() => {
        //  需要维护单调队列
        function maxSlidingWindow(nums, k){
            if (nums.length === 0) {
                return nums;
            }
            //  滑动窗口
//            let slide = nums.slice(0, k);
            //  单调队列，升序
            const list = nums.slice(0, k).sort((a, b) => a - b);
            //  返回值
            const resultArray = [];
            let i = 0;
            while (true) {
                //  先装
                resultArray.push(list[list.length - 1]);
                //  删除第一个
                const index = nums[i];
                //  队列里删除第一个
                list.splice(list.indexOf(index), 1);
                //  二分
                let left = 0;
                let right = list.length - 1;
                //  新增的值
                const newValue = nums[k + i];
                if (newValue === undefined) {
                    break;
                }
                while (left <= right) {
                    const middle = (left + right) >> 1;
                    const middleValue = list[middle];
                    if (middleValue > newValue) {
                        right = middle - 1;
                    } else if (middleValue < newValue) {
                        left = middle + 1;
                    } else {
                        left = middle;
                        break;
                    }
                }
                //  新增值
                list.splice(right, 0, newValue);
                i++;
            }

            return resultArray;
        }

        maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3);

    })();
</script>
<p class="red">剑指 Offer 60. n个骰子的点数</p>
<script data-msg="剑指 Offer 60. n个骰子的点数">
    (() => {
        //  排列组合
        function twoSum(n){
            const total = Math.pow(6, n);
            const type = [1, 2, 3, 4, 5, 6];
            const res = [];
            const map = {
                1: 0,
                2: 0,
                3: 0,
                4: 0,
                5: 0,
                6: 0,
            };
            while (n--) {
                const temp = [];
                for (let value of type) {
                    for (let _value of res) {
                        const key = value + _value;
                        temp.push(key);
                        map[key] = map[key] || 0;
                        map[key]++;
                    }
                }

            }
        }
    })();
</script>
<p>剑指 Offer 61. 扑克牌中的顺子</p>
<script data-msg="剑指 Offer 61. 扑克牌中的顺子">
    (() => {
        function isStraight(list){
            let min;
            let max;
            const map = {};
            for (const item of list) {
                if (item === 0) {
                    continue;
                }
                //  重复
                if (map[item]) {
                    return false;
                }
                map[item] = 1;
                //  初始值
                if (min === undefined) {
                    min = item;
                    max = item;
                    continue;
                }
                //  更小
                if (min > item) {
                    min = item;
                    continue;
                }
                //  更大
                if (max < item) {
                    max = item;
                }
            }
            return (max - min < 5);
        }

        isStraight([0, 0, 2, 2, 5]);
    })();
</script>
<p class="red">剑指 Offer 62. 圆圈中最后剩下的数字</p>
<script data-msg="剑指 Offer 62. 圆圈中最后剩下的数字">
    (() => {
        return;

        //  我日
        function lastRemaining(n, m){
            let x = 0;
            let i = 1;
            while (i <= n) {
                x = (x + m) % i;
                i++;
            }
            return x;
        }

//        debugger
        const res = lastRemaining(5, 3);
        console.log(res);
        //  0、1、2、3、4
        //  1
        //  0、1、2、3     4
        //  2
        //  1、3、0、4     2
        //  3
        //  2、0、4、1     3
        //  4
        //  3、2、4、1     0
        //  5
        //  4、0、2、3     1

        //  0、1、2、3
        //  1
        //  0、1、2       3
        //  2
        //  1、3、2       0
        //  3
        //  2、3、0       2
        //  4
        //  3、0、2       1

        //  0、1、2
        //  1
        //  0、1         2
        //  2
        //  1、0         2
        //  3
        //  2、0         1

    })();
</script>
<p class="red">剑指 Offer 65. 不用加减乘除做加法</p>
<script data-msg="剑指 Offer 65. 不用加减乘除做加法">
    (() => {
        //  看解题
        function add(a, b){
            while (b !== 0) {
                const c = (a&b) << 1;  // c = 进位
                a ^= b; // a = 非进位和
                b = c; // b = 进位
            }
            return a;
        }

        add(1, 2);
    })();
</script>
<p>剑指 Offer 66. 构建乘积数组</p>
<script data-msg="剑指 Offer 66. 构建乘积数组">
    (() => {
        function constructArr(a){
            if (a.length === 0) {
                return a;
            }
            const b = [];

            for (let i = 0; i < a.length; i++) {
                let item = a[i - 1];
                item = item === undefined ? 1 : item;
                b[i] = item * (b[i - 1] === undefined ? 1 : b[i - 1]);
            }
            let sum = 1;
            for (let i = a.length - 1; i >= 0; i--) {
                let item = a[i + 1];
                item = item === undefined ? 1 : item;
                sum *= item;
                b[i] = sum * b[i];
            }

            return b;
        }

        constructArr([1, 2, 3, 4, 5]);

    })();
</script>
<p class="red">面试题 01.01. 判定字符是否唯一</p>
<script data-msg="面试题 01.01. 判定字符是否唯一">
    (() => {
        //  ✅✅✅✅
        //  按位运算存值，原理相当于字符串存值 '00001' -> '00010'
        //  按位将1左移几位，就变成了 '01几个零'，这样的二进制数
        //  移动a位和b位，他们是肯定不会重复的，所以如果mark的值为 '0110' 时，说明分别有过2和1，也就是出现了 c和b
        //  然后按位与，如果新出来一个c，左移动3位后，是 '0100'，与一下 '0110'就不为 0，说明c重复了
        /**
         * @param {string} astr
         * @return {boolean}
         */
        function isUnique(astr){
            //  用位运算保存
            let mark = 0;
            for (let value of astr) {
                const index = value.charCodeAt(0) - 97;
                //  左移动几位
                const left = 1 << index;
                if ((mark&left) !== 0) {
                    //  重复
                    return false;
                }
                mark = mark|left;
            }
            return true;
        }

        isUnique('bcdb'.toLowerCase());
    })();
</script>
<p>面试题 01.02. 判定是否互为字符重排</p>
<script data-msg="面试题 01.02. 判定是否互为字符重排">
    (() => {
        function CheckPermutation(s1, s2){
            if (s1.length !== s2.length) {
                return false;
            }
            const map = {};
            for (let value of s1) {
                map[value] = map[value] || 0;
                map[value]++;
            }
            for (let value of s2) {
                if (map[value] === undefined || map[value] === 0) {
                    return false;
                }
                map[value]--;
            }
            return true;
        }

    })();
</script>
<p>面试题 01.03. URL化</p>
<script data-msg="面试题 01.03. URL化">
    (() => {
        function replaceSpaces(S, length){
            return encodeURI(S.slice(0, length));
        }

        return;
        //  由一些不转，斜杠不转
        console.log(escape('http://www.w3school.com.cn'));// http%3A//www.w3school.com.cn
        console.log(escape('http://www.w3school.com.cn/My first/'));//http%3A//www.w3school.com.cn/My%20first/
        console.log(escape('?!=()#%&')); // %3F%21%3D%28%29%23%25%26
        console.log('\n');
        console.log((encodeURI('http://www.w3school.com.cn'))); //http://www.w3school.com.cn
        console.log((encodeURI('http://www.w3school.com.cn/My first/'))); // http://www.w3school.com.cn/My%20first/
        console.log((encodeURI(',/?:@&=+$#'))); // ,/?:@&=+$#
        console.log('\n');
        console.log((encodeURIComponent('http://www.w3school.com.cn'))); // http%3A%2F%2Fwww.w3school.com.cn
        console.log((encodeURIComponent('http://www.w3school.com.cn/p 1/id?=giao'))); // http%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2Fid%3F%3Dgiao
        console.log((encodeURIComponent(',/?:@&=+$#')));//%2C%2F%3F%3A%40%26%3D%2B%24%23

    })();
</script>
<p>面试题 01.04. 回文排列</p>
<script data-msg="面试题 01.04. 回文排列">
    (() => {
        //  第一层，使用map
        function canPermutePalindrome(s){
            const map = {};
            let count = 0;
            for (let value of s) {
                if (map[value]) {
                    delete map[value];
                    count--;
                } else {
                    map[value] = true;
                    count++;
                }
            }
            return count < 2;
        }

        //  第二层，使用位运算   ⚠️这个仅用于字母
        function canPermutePalindrome(s){
            let mark = 0;
            for (let value of s) {
                const index = 1 << value.charCodeAt(0);
                //  重复了
                if ((mark&index) !== 0) {
                    mark = (mark^index);
                } else {
                    mark = (mark|index);
                }
            }
            //  完全对称
            if (mark === 0) {
                return true;
            }
            while (mark > 1) {
                mark /= 2;
                if (Math.trunc(mark) !== mark) {
                    return false;
                }
            }
            return true;
        }

        const res = canPermutePalindrome('AaBb//a');
//        console.log(res);
    })();
</script>
<p>面试题 01.06. 字符串压缩</p>
<script data-msg="面试题 01.06. 字符串压缩">
    (() => {
        function compressString(s){
            let res = '';
            let prev = '';
            let count = '';
            for (let value of s) {
                if (value === prev) {
                    count++;
                } else {
                    prev = value;
                    res += count + value;
                    count = 1;
                }
            }
            res += count;
            return res.length >= s.length ? s : res;
        }
    })();
</script>
<p>面试题 01.09. 字符串轮转</p>
<script data-msg="面试题 01.09. 字符串轮转">
    (() => {
        function isFlipedString(s1, s2){
            if (s1.length !== s2.length) {
                return false;
            }
            return (s1 + s1).includes(s2);
        }
    })();
</script>
<p class="red">面试题 02.01. 移除重复节点</p>
<script data-msg="面试题 02.01. 移除重复节点">
    (() => {
        function removeDuplicateNodes(head){

        }
    })();
</script>
<p>面试题 02.02. 返回倒数第 k 个节点</p>
<script data-msg="面试题 02.02. 返回倒数第 k 个节点">
    (() => {
        function kthToLast(head, k){
            let node = head;
            let slow = head;
            while (node) {
                k--;
                if (k <= 0) {
                    slow = slow.next;
                }
                node = node.next;
            }
            return slow.val;
        }
    })();
</script>
<p>面试题 02.03. 删除中间节点</p>
<script data-msg="面试题 02.03. 删除中间节点">
    (() => {
        function deleteNode(node){
            let next = node.next;
            node.next = next.next;
            node.val = next.val;
        }

    })();
</script>
<p>面试题 02.06. 回文链表</p>
<script data-msg="面试题 02.06. 回文链表">
    (() => {
        function isPalindrome(head){
            const list = [];
            while (head) {
                list.push(head.val);
                head = head.next;
            }
            const len = Math.trunc(list.length / 2) + 1;
            const len1 = list.length - 1;
            for (let i = 0; i < len; i++) {
                if (list[len1 - i] !== list[i]) {
                    return false;
                }
            }
            return true;
        }
    })();
</script>
<p>面试题 02.07. 链表相交</p>
<script data-msg="面试题 02.07. 链表相交">
    (() => {
        //  两边循环完了以后就会同时变成null
        function getIntersectionNode(headA, headB){
            let nodeA = headA;
            let nodeB = headB;
            while (nodeA !== nodeB) {
                if (nodeA === null) {
                    nodeA = headB;
                } else {
                    nodeA = nodeA.next;
                }
                if (nodeB === null) {
                    nodeB = headA;
                } else {
                    nodeB = nodeB.next;
                }
            }
            return nodeA;
        }
    })();
</script>
<p class="orange">面试题 03.01. 三合一</p>
<script data-msg="面试题 03.01. 三合一">
    (() => {
        //  注意题意
        function TripleInOne(stackSize){
            this.list = new Array(stackSize * 3);
            this.stackSize = stackSize;
        }

        TripleInOne.prototype.push = function (stackNum, value){
            const firstIndex = stackNum * this.stackSize;
            const lastIndex = (stackNum + 1) * this.stackSize - 1;
            //  在这个区间
            for (let i = firstIndex; i <= lastIndex; i++) {
                if (this.list[i] === undefined) {
                    this.list[i] = value;
                    break;
                }
            }
        };

        //  栈底
        TripleInOne.prototype.peek = function (stackNum){
            const firstIndex = stackNum * this.stackSize;
            const lastIndex = (stackNum + 1) * this.stackSize - 1;
            for (let i = lastIndex; i >= firstIndex; i--) {
                const item = this.list[i];
                if (item !== undefined) {
                    return item;
                }
            }
            //  没有
            return -1;
        };

        TripleInOne.prototype.pop = function (stackNum){
            const firstIndex = stackNum * this.stackSize;
            const lastIndex = (stackNum + 1) * this.stackSize - 1;
            for (let i = lastIndex; i >= firstIndex; i--) {
                const item = this.list[i];
                if (item !== undefined) {
                    this.list[i] = undefined;
                    return item;
                }
            }
            //  没有
            return -1;
        };

        TripleInOne.prototype.isEmpty = function (stackNum){
            const firstIndex = stackNum * this.stackSize;
            const lastIndex = (stackNum + 1) * this.stackSize - 1;
            for (let i = firstIndex; i < lastIndex; i++) {
                if (this.list[i] !== undefined) {
                    return false;
                }
            }
            return true;
        };
    })();
</script>
<p>面试题 03.02. 栈的最小值</p>
<script data-msg="面试题 03.02. 栈的最小值">
    (() => {
        function MinStack(){
            this.list = [];
            //  非递减数组
            this.minList = [];
        }

        MinStack.prototype.push = function (x){
            this.list.push(x);
            if (this.minList[0] >= x || this.minList.length === 0) {
                this.minList.unshift(x);
            }
        };

        MinStack.prototype.pop = function (){
            if (this.list.length === -1) {
                return -1;
            }
            const pop = this.list.pop();
            if (this.minList[0] === pop) {
                this.minList.shift();
            }
            return pop;
        };

        MinStack.prototype.top = function (){
            return this.list[this.list.length - 1];
        };

        MinStack.prototype.getMin = function (){
            return this.minList[0];
        };

    })();
</script>
<p class="red">面试题 03.04. 化栈为队</p>
<script data-msg="面试题 03.04. 化栈为队">
    //  没理解题意
    (() => {
        function MyQueue(){
            this.list = [];
        }

        MyQueue.prototype.push = function (x){
            this.list.push(x);
        };

        MyQueue.prototype.pop = function (){
            return this.list.shift();
        };
        MyQueue.prototype.peek = function (){
            return this.list[0];
        };

        MyQueue.prototype.empty = function (){
            return this.list.length === 0;
        };
    })();
</script>
<p>面试题 03.06. 动物收容所</p>
<script data-msg="面试题 03.06. 动物收容所">
    (() => {
        //  不想做
        function AnimalShelf(){
            //  最小动物编号
            this.minDog = Infinity;
            this.minCat = Infinity;
            this.catList = [];
            this.dogList = [];
        }

        //  [编号，种类：0：猫，1：狗]
        AnimalShelf.prototype.enqueue = function (animal){
            if (animal[1]) {
                if (this.dogList.length === 0) {
                    this.minDog = animal[0];
                }
                //  狗
                this.dogList.push(animal);
            } else {
                if (this.catList.length === 0) {
                    this.minCat = animal[0];
                }
                //  猫
                this.catList.push(animal);
            }
        };

        //  [编号，种类：0：猫，1：狗]
        AnimalShelf.prototype.dequeueAny = function (){
            if (this.minCat === Infinity && this.minDog === Infinity) {
                return [-1, -1];
            }
            if (this.minCat < this.minDog) {
                const cat = this.catList.shift();
                this.minCat = this.catList[0] ? this.catList[0][0] : Infinity;
                return cat;
            }
            const dog = this.dogList.shift();
            this.minDog = this.dogList[0] ? this.dogList[0][0] : Infinity;
            return dog;
        };
        AnimalShelf.prototype.dequeueDog = function (){
            if (this.minDog === Infinity) {
                return [-1, -1];
            }
            const dog = this.dogList.shift();
            this.minDog = this.dogList[0] ? this.dogList[0][0] : Infinity;
            return dog;
        };

        AnimalShelf.prototype.dequeueCat = function (){
            if (this.minCat === Infinity) {
                return [-1, -1];
            }
            const cat = this.catList.shift();
            this.minCat = this.catList[0] ? this.catList[0][0] : Infinity;
            return cat;
        };
    })();
</script>
<p class="green">面试题 04.02. 最小高度树</p>
<script data-msg="面试题 04.02. 最小高度树">
    (() => {
        return;

        function sortedArrayToBST(nums){
            if (nums.length === 0) {
                return null;
            }
            //  除以二取整数
            let middleIndex = nums.length >> 1;
            let root = new TreeNode(nums[middleIndex]);
            root.left = sortedArrayToBST(nums.slice(0, middleIndex));
            root.right = sortedArrayToBST(nums.slice(middleIndex + 1));
            return root;
        }

        const res = sortedArrayToBST([-10, -3, 0, 5, 9]);
        console.log(res);
    })();
</script>
<h3 class="green">面试题 04.04. 检查平衡性</h3>
<script data-msg="面试题 04.04. 检查平衡性">
    (() => {
        function isBalanced(root){
            if (root === null) {
                return true;
            }
            return getTier(root, 1);
        }

        function getTier(node, tier){
            if (node === null) {
                return tier;
            }
            let left = node.left ? getTier(node.left, tier + 1) : tier;
            if (left === false) {
                return false;
            }
            let right = node.right ? getTier(node.right, tier + 1) : tier;
            if (right === false) {
                return false;
            }
            if (Math.abs(left - right) > 1) {
                return false;
            }
            return Math.max(left, right);
        }

        [1, null, 2, null, 3];
        [1, 2, 2, 3, 3, null, null, 4, 4];
    })();
</script>
<p>面试题 05.01. 插入</p>
<script data-msg="面试题 05.01. 插入">
    (() => {
        //  不想做
        function insertBits(N, M, i, j){
            let t = 0;
            for (let x = i; x <= j; x++) {
                t = t|(1 << x);
            }
            t = ~t;
            N = N&t;
            M = M << i;
            return N|M;
        }
    })();
</script>
<p>面试题 05.03. 翻转数位</p>
<script data-msg="面试题 05.03. 翻转数位">
    (() => {
        function reverseBits(nums){
            let str = '';
            while (nums > 0) {
                str = nums % 2 + str;
                nums = nums >> 1;
            }
            str = str || '0';
            const list = str.split('0');
            let max = 0;
            for (let i = 0; i < list.length - 1; i++) {
                const _max = list[i].length + list[i + 1].length;
                if (max < _max) {
                    max = _max;
                }
            }
            if (list.length === 1) {
                return list[0].length + 1;
            }
            return max + 1;
        }

        reverseBits(2147483647);
    })();
</script>
<p class="red">面试题 05.06. 整数转换</p>
<script data-msg="面试题 05.06. 整数转换">
    (() => {
        return;
        //  异或，然后统计1的个数。
        //  ⚠️这个还要按符号右移？？？
        function convertInteger(A, B){
            let count = 0;
            let value = A^B;
            while (value) {
                count += (value&1);
                value = value >>> 1;
            }
            return count;
        }

        const res = convertInteger(826966453, -729934991);
        console.log(res);
    })();
</script>
<p class="red">面试题 05.07. 配对交换</p>
<script data-msg="面试题 05.07. 配对交换">
    (() => {
        return;

        //  为什么
        function exchangeBits(num){
            let str = num.toString(2);
            if (str.length % 2) {
                str = 0 + str;
            }
            let res = '';
            for (let i = str.length - 1; i >= 0; i--) {
                if (i % 2) {
                    res = (str[i - 1] || 0) + res;
                } else {
                    res = (str[i + 1] || 0) + res;
                }
            }
            return parseInt(res, 2);
        }

        const res = exchangeBits(520721303);
        console.log(res);

        //  ❕❕❕❕❕❕❕❕❕❕❕
        //  这个，0xaaaaaaaa === 0b101010101010101010 , 32位
        //  它的每一个偶数位都是1，所以按位与一下 num，就会得到 num的所有偶数的值
        //  反之 ,0x55555555
        //  可以得到奇数位的值，那么，奇数位与偶数位互换一下
        //  最后按位或
        function exchangeBits(num){
            let odd = 0x55555555&num;
            let even = 0xaaaaaaaa&num;
            return (odd << 1)|(even >> 1);
        }
    })();
</script>
<p class="red">面试题 08.01. 三步问题</p>
<script data-msg="面试题 08.01. 三步问题">
    (() => {
        return;

        //  递归爆栈，需要尾递归
        function waysToStep(n){
            if (n < 3) {
                return n;
            }
            let one = 1;
            let two = 2;
            let three = 4;
            n -= 3;
            while (n--) {
                const _three = three;
                three = (one + two + three) % 1000000007;
                one = two;
                two = _three;
            }
            return three;
        }

        function waysToStep(n){
            if (n < 3) {
                return n;
            }
            n -= 3;
            return getValue(n);
        }

        function getValue(n, a, b, total){
            a = a || 1;
            b = b || 2;
            total = total || 4;
            total = total % 1000000007;
            if (!n) {
                return total;
            }
            return getValue(n - 1, b, total, total + a + b);
        }

        const value = getValue(900750);
        console.log(value);

        for (let i = 1; i < 10; i++) {
            console.log(i, waysToStep(i));
        }
    })();
</script>
<p>面试题 08.03. 魔术索引</p>
<script data-msg="面试题 08.03. 魔术索引">
    (() => {
        function findMagicIndex(list){
            if (list[0] === 0) {
                return 0;
            }
            for (let i = 0; i < list.length;) {
                const current = list[i];
                if (i === current) {
                    return i;
                }
                i = i > current ? i + 1 : current;
            }
            return -1;
        }
    })();
</script>
<p class="red">面试题 08.06. 汉诺塔问题</p>
<script data-msg="面试题 08.06. 汉诺塔问题">
    (() => {
        //  递归分治
        function hanota(a, b, c){
            const len = a.length;
            move(a, b, c, len);
        }

        function move(a, b, c, len){
            if (len === 1) {
                c.push(a.pop());
                return;
            }
            move(a, c, b, len - 1);
            c.push(a.pop());
            move(b, a, c, len - 1);
        }

        hanota([3, 2, 1], [], []);
        //  a               b           c

        //  [4, 3, 2, 1]    []          []
        //  [4,3,2]         [1]         []
        //  [4,3]           [1]         [2]
        //  [4,3]           []          [2,1]

        //  [4]             [3]         [2,1]
        //  [4,1]           [3]         [2]
        //  [4,1]           [3,2]       []
        //  [4]             [3,2,1]     []
        //  [4]             [3,2,1]     []
        //  []              [3,2,1]     [4]
        //  []              []          [4,3,2,1]

        //  ❕❕❕❕❕❕❕❕❕❕❕❕
        //  1.将a上面的前n-1个移动到b
        //  2.将a上到唯一一个移动到c
        //  3.将b上到n-1个移动到c
        
    })();
</script>
</body>
</html>













