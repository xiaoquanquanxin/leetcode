<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>599-783</title>
    <link rel="stylesheet" href="../css/index.css">
</head>
<body>
<p class="green">700. 二叉搜索树中的搜索，给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<script data-msg="700. 二叉搜索树中的搜索">
    (() => {

    })();
</script>
<p>703. 数据流中的第K大元素，设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。你的 KthLargest 类需要一个同时接收整数 k
    和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。</p>
<script data-msg="703. 数据流中的第K大元素">
    (() => {
        return;

        function KthLargest(k, nums){
            this.kthLargest = nums.sort((a, b) => a - b);
            this.k = k;
        }

        KthLargest.prototype.add = function (val){
            const list = this.kthLargest;
            if (val >= list[list.length - 1] || list.length === 0) {
                list.push(val);
            } else if (val < list[0]) {
                list.unshift(val);
            } else {
                for (let i = list.length - 1; i >= 0; i--) {
                    if (val >= list[i]) {
                        list.splice(i + 1, 0, val);
                        break;
                    }
                }
            }
            // console.log(list, this.k);
            return list[list.length - this.k];
        };
        const k = new KthLargest(2, [0]);

        [[-1], [1], [-2], [-4], [3]].forEach(item => {
            k.add(item[0]);
        });
        //  function KthLargest(k, nums){
        //      debugger
        //     this.data = nums;
        //     this.k = k;
        //     let len = this.data.length;
        //     let parent = Math.floor((len - 2) / 2);
        //     this.shiftDown = function (k){
        //         while (k * 2 + 1 < this.data.length) {
        //             let j = k * 2 + 1;
        //             if (k * 2 + 2 < this.data.length && this.data[j] > this.data[j + 1]) {
        //                 j += 1;
        //             }
        //             if (this.data[k] > this.data[j]) {
        //                 let m = this.data[k];
        //                 this.data[k] = this.data[j];
        //                 this.data[j] = m;
        //                 k = j;
        //             } else {
        //                 break;
        //             }
        //         }
        //     };
        //     this.shiftUp = function (k){
        //         while (k > 0) {
        //             let parent = Math.floor((k - 1) / 2);
        //             if (this.data[parent] > this.data[k]) {
        //                 let m = this.data[k];
        //                 this.data[k] = this.data[parent];
        //                 this.data[parent] = m;
        //                 k = parent;
        //             } else {
        //                 break;
        //             }
        //         }
        //     };
        //     this.extracMin = function (){
        //         this.data[0] = this.data[this.data.length - 1];
        //         this.data.pop();
        //         this.shiftDown(0);
        //     };
        //     for (parent; parent >= 0; parent--) {
        //         this.shiftDown(parent);
        //     }
        //     while (this.data.length > k) {
        //         this.extracMin();
        //     }
        // };
        // KthLargest.prototype.add = function (val){
        //     debugger
        //     if (this.data.length < this.k) {
        //         this.data.push(val);
        //         this.shiftUp(this.data.length - 1);
        //     } else {
        //         if (val > this.data[0]) {
        //             this.data[0] = val;
        //             this.shiftDown(0);
        //         }
        //
        //     }
        //     return this.data[0];
        // };
        //
        // const k = new KthLargest(2, [0]);
        // console.log(k.add(-1));
        // console.log(k.add(1));
        // console.log(k.add(1));
        // console.log(k.add(-2));
        // console.log(k.add(-4));
        // console.log(k.add(3));
    })();
</script>
<p>704. 二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<script data-msg="704. 二分查找">
    (() => {
        return;

        //  这是夹逼准则
        function search(nums, target){
            let left = 0;
            let right = nums.length - 1;
            while (right >= left) {
                if (nums[right] === target) {
                    return right;
                } else if (nums[left] === target) {
                    return left;
                }
                const center = Math.floor((left + right) / 2);
                if (nums[center] === target) {
                    return center;
                } else if (nums[center] > target) {
                    left++;
                    right = center - 1;
                } else {
                    right--;
                    left = center + 1;
                }
            }
            return -1;
        }

        const arr = [
            [[-1, 0, 3, 5, 9, 12], 2],
            [[1, 3], 1],
            [[-1, 0, 3, 5, 9, 12], 9],
            [[2, 5], 5],
            [[-1, 0, 3, 5, 9, 12], -1],
            [[-1, 0, 3, 5, 9, 12], 0]
        ];
        for (let i = 0; i < arr.length; i++) {
            const res = search(arr[i][0], arr[i][1]);
            console.log(res);
        }
    })();
</script>
<p>705. 设计哈希集合，不使用任何内建的哈希表库设计一个哈希集合.具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。
    remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p>
<script data-msg="705. 设计哈希集合">
    (() => {
        //  略
    })();
</script>
<p>706. 设计哈希映射，</p>
<script data-msg="706. 设计哈希映射">
    (() => {
        //  略
    })();
</script>
<p>709. 转换成小写字母，实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p>
<p class="red">''.codePointAt和String.fromCodePoint对应，处理unicode32位的字符，''.charCodeAt和String.fromCharCode对应。</p>
<script data-msg="709. 转换成小写字母">
    (() => {
        function toLowerCase(str){
            let res = '';
            for (let i = 0; i < str.length; i++) {
                const unicode = str.codePointAt(i);
                if (unicode >= 64 && unicode <= 89) {
                    res += String.fromCodePoint(unicode + 32);
                } else {
                    res += str[i];
                }
            }
            return res;
        }
    })();
</script>
<p>717. 1比特与2比特字符，有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p>
<script data-msg="717. 1比特与2比特字符">
    (() => {
        return;

        function isOneBitCharacter(bits){
            let len1 = bits.length - 1;
            let len2 = len1 - 1;
            if (bits[len1] === 0) {
                let current = bits[len2];
                let count = 0;
                while (current === 1) {
                    count++;
                    current = bits[len2 - count];
                }
                if (count % 2 === 1) {
                    return false;
                }
            }
            return true;
        }

        const res = isOneBitCharacter([0]);
        console.log(res);
    })();
</script>
<p>720. 词典中最长的单词，给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。
    若无答案，则返回空字符串。</p>
<script data-msg="720. 词典中最长的单词">
    (() => {
        return;

        function longestWord(words){
            const map = {};
            let maxLength = 0;
            words.forEach((item, index) => {
                map[item] = item.length;
                maxLength = Math.max(maxLength, item.length);
            });
            while (maxLength) {
                const _words = words.filter(item => item.length === maxLength).sort();
                for (let i = 0; i < _words.length; i++) {
                    let _str = _words[i];
                    while (map[_str] !== undefined) {
                        if (_str.length === 1) {
                            return _words[i];
                        }
                        _str = _str.slice(0, _str.length - 1);
                        if (_str === '') {
                            break;
                        }
                    }
                }
                maxLength--;
            }
            return '';
        }

        // const res = longestWord(['w', 'wo', 'wor', 'worl', 'world']);
        const res = longestWord(['a', 'banana', 'app', 'appl', 'ap', 'apply', 'apple']);

        // const res = longestWord(['b', 'br', 'bre', 'brea', 'break', 'breakf', 'breakfa', 'breakfas', 'breakfast', 'l', 'lu', 'lun', 'lunc', 'lunch', 'd', 'di', 'din', 'dinn', 'dinne', 'dinner']);
        // const res = longestWord(['m', 'mo', 'moc', 'moch', 'mocha', 'l', 'la', 'lat', 'latt', 'latte', 'c', 'ca', 'cat']);
        // const res = longestWord(['yo', 'ew', 'fc', 'zrc', 'yodn', 'fcm', 'qm', 'qmo', 'fcmz', 'z', 'ewq', 'yod', 'ewqz', 'y']);
        console.log(res);

    })();
</script>
<p>724. 寻找数组的中心索引，给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。
    如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>
<script data-msg="724. 寻找数组的中心索引">
    (() => {
        return;

        function pivotIndex(nums){
            if (nums.length <= 1) {
                return -1;
            }
            let leftSum = 0;
            let center = 0;
            let right = 1;
            let rightSum = nums.slice(right).reduce(((previousValue, currentValue) => previousValue + currentValue), 0);

            while (center < nums.length) {
                if (leftSum === rightSum) {
                    return center;
                }
                leftSum += nums[center];
                rightSum -= nums[right];
                center++;
                right++;
            }
            return -1;
        }

        // const res = pivotIndex([-1, -1, -1, 0, 1, 1]);
        const res = pivotIndex([-1, -1, 0, 1, 1, 0]);
        console.log(res);

    })();
</script>
<p>728. 自除数，自除数 是指可以被它包含的每一位数除尽的数。 例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。 还有，自除数不允许包含 0 。
    给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。</p>
<script data-msg="728. 自除数">
    (() => {
        return;

        function selfDividingNumbers(left, right){
            const arr = [];
            while (right >= left) {
                const _right = left.toString();
                //  不包含零
                if (!_right.includes('0')) {
                    let len = _right.length;
                    let isValidate = true;
                    while (len-- > 0) {
                        if (left % _right[len] !== 0) {
                            isValidate = false;
                            break;
                        }
                    }
                    if (isValidate) {
                        arr.push(left);
                    }
                }
                left++;
            }
            return arr;
        }

        const res = selfDividingNumbers(1, 22);
        console.log(res);

    })();
</script>
<p>733. 图像渲染，有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行
    ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
    为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。
    最后返回经过上色渲染后的图像。</p>
<script data-msg="733. 图像渲染">
    (() => {
        return;

        function floodFill(arr, sr, sc, newColor){
            function render(_sr, _sc){
                if (arr[_sr][_sc] !== prevColor) {
                    return;
                }
                arr[_sr][_sc] = newColor;
                render(_sr, _sc - 1);
                render(_sr, _sc + 1);
                arr[_sr - 1] && render(_sr - 1, _sc);
                arr[_sr + 1] && render(_sr + 1, _sc);
            }

            //  以前的颜色
            const prevColor = arr[sr][sc];
            if (prevColor === newColor) {
                return arr;
            }
            render(sr, sc);
            return arr;
        }

        // const res = floodFill([[0, 0, 0], [0, 1, 1]], 1, 1, 1);
        const res = floodFill([[1, 1, 1], [1, 1, 0], [1, 0, 1]], 1, 1, 2);
        console.log(res);
    })();
</script>
<p class="orange">744. 寻找比目标字母大的最小字母，给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。
    在比较时，字母是依序循环出现的。举个例子：
    如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'</p>
<script data-msg="744. 寻找比目标字母大的最小字母">
    (() => {
        return;

        function nextGreatestLetter(letters, target){
            const unicodeTarget = target.charCodeAt(0);
            for (let i = 0; i < letters.length; i++) {
                const current = letters[i].charCodeAt(0);
                if (unicodeTarget < current) {
                    return letters[i];
                }
            }
            return letters[0];
        }

        // const res = nextGreatestLetter(['c', 'f', 'j'], 'a');
        const res = nextGreatestLetter(['c', 'f', 'j'], 'd');
        console.log(res);
    })();
</script>
<p class="red">746. 使用最小花费爬楼梯，数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
    每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
    您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
</p>
<script data-msg="746. 使用最小花费爬楼梯">
    (() => {
        function minCostClimbingStairs(cost){

        }

    })();
</script>
<p>747. 至少是其他数字两倍的最大数，在一个给定的数组nums中，总是存在一个最大元素 。 查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 如果是，则返回最大元素的索引，否则返回-1。</p>
<script data-msg="747. 至少是其他数字两倍的最大数">
    (() => {
        return;

        function dominantIndex(list){
            const max = Math.max(...list);
            const maxIndex = list.indexOf(max);
            list.splice(maxIndex, 1);
            const second = Math.max(...list);
            if (second * 2 <= max) {
                return maxIndex;
            }
            return -1;
        }

        dominantIndex([0, 0, 2, 3]);
    })();
</script>
<p>748. 最短完整词，如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。在所有完整词中，最短的单词我们称之为最短完整词。
    单词在匹配牌照中的字母时不区分大小写，比如牌照中的 "P" 依然可以匹配单词中的 "p" 字母。
    我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。
    牌照中可能包含多个相同的字符，比如说：对于牌照 "PP"，单词 "pair" 无法匹配，但是 "supper" 可以匹配。</p>
<script data-msg="748. 最短完整词">
    (() => {
        return;

        function shortestCompletingWord(licensePlate, words){
            licensePlate = licensePlate.replace(/[^a-zA-Z]/g, '').toLowerCase();
            let map = {};
            let minLength = 0;
            for (let key of licensePlate) {
                map[key] = map[key] || 0;
                map[key]++;
                minLength++;
            }
            words = words.filter(item => item.length >= minLength);
            const wordsList = [];
            for (let i = 0; i < words.length; i++) {
                const len = words[i].length;
                wordsList[len] = wordsList[len] || [];
                wordsList[len].push(words[i]);
            }
            for (let i = 0; i < wordsList.length; i++) {
                const arr = wordsList[i] || [];
                for (let j = 0; j < arr.length; j++) {
                    const str = arr[j];
                    let _map = JSON.parse(JSON.stringify(map));
                    _map.keyLength = minLength;
                    for (let key of str) {
                        if (_map[key] === 1) {
                            delete _map[key];
                            _map.keyLength--;
                        } else if (_map[key]) {
                            _map[key]--;
                            _map.keyLength--;
                        }
                    }
                    if (_map.keyLength === 0) {
                        return str;
                    }
                    _map = null;
                }
            }
        }

        // const res = shortestCompletingWord('1s3 PSt', ['step', 'steps', 'stripe', 'stepple']);
        // const res = shortestCompletingWord('1s3 456', ['looks', 'pest', 'stew', 'show']);
        const res = shortestCompletingWord('GrC8950', ['measure', 'other', 'every', 'base', 'according', 'level', 'meeting', 'none', 'marriage', 'rest']);

        console.log(res);
    })();
</script>
<p>762. 二进制表示中质数个计算置位，给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3
    个计算置位。还有，1 不是质数。）</p>
<script data-msg="762. 二进制表示中质数个计算置位">
    (() => {
        return;

        function countPrimeSetBits(L, R){
            const map = {
                2: true,
                3: true,
                5: true,
                7: true,
                11: true,
                13: true,
                17: true,
                19: true,
            };
            let count = 0;
            for (let i = L; i <= R; i++) {
                let _i = i;
                let len = 0;
                while (_i) {
                    if (_i % 2) {
                        len++;
                    }
                    _i = Math.floor(_i / 2);
                }

                if (map[len]) {
                    count++;
                }
            }
            return count;
        }

        console.time('1');
        const res = countPrimeSetBits(10000, 100000);
        console.log(res);
        console.timeEnd('1');
    })();
</script>
<p>766. 托普利茨矩阵，如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。 给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。</p>
<script data-msg="766. 托普利茨矩阵">
    (() => {
        function isToeplitzMatrix(matrix){
            const map = {};
            for (let i = 0; i < matrix.length; i++) {
                const row = matrix[i];
                for (let j = 0; j < row.length; j++) {
                    const key = j - i;
                    if (map[key] === undefined) {
                        map[key] = row[j];
                        continue;
                    }
                    if (map[key] !== row[j]) {
                        return false;
                    }
                }
            }
            return true;
        }

    })();
</script>
<p>771. 宝石与石头，给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
    J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。</p>
<script data-msg="771. 宝石与石头">
    (() => {
        function numJewelsInStones(J, S){
            const map = {};
            for (let key of J) {
                map[key] = true;
            }
            let res = 0;
            for (let key of S) {
                if (map[key]) {
                    res++;
                }
            }
            return res;

        }
    })();
</script>
<p class="green">783. 二叉搜索树节点最小距离，给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。</p>
<script data-msg="783. 二叉搜索树节点最小距离">
    (() => {

    })();
</script>
<p>784. 字母大小写全排列，给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p>
<script data-msg="784. 字母大小写全排列">
    (() => {
        return;

        function letterCasePermutation(str){
            const arr = arguments[1] || [''];
            const index = arguments[2] || 0;
            if (!str.length) {
                return arr;
            }
            const _arr = arr.splice(0, Infinity);
            const unicode = str.charCodeAt(0);
            let keyList = [];
            if (unicode >= 97 && unicode <= 122 || unicode >= 65 && unicode <= 90) {
                keyList.push(str[0].toLowerCase());
                keyList.push(str[0].toUpperCase());
            } else {
                keyList.push(str[0]);
            }
            for (let i = 0; i < _arr.length; i++) {
                for (let j = 0; j < keyList.length; j++) {
                    arr.push(_arr[i] + keyList[j]);
                }
            }
            keyList = null;
            str = str.slice(1);
            return letterCasePermutation(str, arr, index + 1);
        }

        const res = letterCasePermutation('FjkZh');
        console.table(res);

    })();
</script>
<p>788. 旋转数字，我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。
    如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9
    同理，除了这些以外其他的数字旋转以后都不再是有效的数字。
    现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？</p>
<script data-msg="788. 旋转数字">
    (() => {
        return;

        function rotatedDigits(N){
            let sum = 0;
            let i = 1;
            let validate = /2|5|6|9/;
            let ill = /3|4|7/;
            while (i <= N) {
                if (!ill.test(i.toString()) && validate.test(i.toString())) {
                    sum++;
                }
                i++;
            }
            return sum;
        }

        const res = rotatedDigits(10);
        console.log(res);
    })();
</script>
<p class="orange">796. 旋转字符串，A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A =
    'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。</p>
<script data-msg="796. 旋转字符串">
    (() => {
        return;

        function rotateString(A, B){
            if (A.length !== B.length) {
                return false;
            }
            const len = A.length;
            let index = 1;
            while (A !== B) {
                A = A.slice(1) + A[0];
                index++;
                if (index > len) {
                    return false;
                }
            }
            return true;
        }

        function rotateString(A, B){
            if (A.length !== B.length) {
                return false;
            }
            A = A + A;
            return A.includes(B);
        }

        debugger
        rotateString('gcmbf', 'fgcmb');
    })();
</script>
<p class="orange">804. 唯一摩尔斯密码词，国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: "a" 对应 ".-", "b" 对应 "-...", "c" 对应
    "-.-.", 等等。
    为了方便，所有26个英文字母对应摩尔斯密码表如下：</p>
<script data-msg="804. 唯一摩尔斯密码词">
    (() => {
        return;
        const wordMap = {
            'a': '.-',
            'b': '-...',
            'c': '-.-.',
            'd': '-..',
            'e': '.',
            'f': '..-.',
            'g': '--.',
            'h': '....',
            'i': '..',
            'j': '.---',
            'k': '-.-',
            'l': '.-..',
            'm': '--',
            'n': '-.',
            'o': '---',
            'p': '.--.',
            'q': '--.-',
            'r': '.-.',
            's': '...',
            't': '-',
            'u': '..-',
            'v': '...-',
            'w': '.--',
            'x': '-..-',
            'y': '-.--',
            'z': '--..'
        };

        function uniqueMorseRepresentations(words){
            const arr = [];
            for (let i = 0; i < words.length; i++) {
                arr[i] = '';
                for (let key of words[i]) {
                    arr[i] += wordMap[key];
                }
            }
            return [...new Set(arr)].length;
        }

        function uniqueMorseRepresentations(words){
            const wordMap = ['.-', '-...', '-.-.', '-..', '.', '..-.', '--.', '....', '..', '.---', '-.-', '.-..', '--', '-.', '---', '.--.', '--.-', '.-.', '...', '-', '..-', '...-', '.--', '-..-', '-.--', '--..'];
            const arr = [];
            for (let i = 0; i < words.length; i++) {
                arr[i] = '';
                for (let key of words[i]) {
                    arr[i] += wordMap[key.toLowerCase().charCodeAt(0) - 97];
                }
            }
            return [...new Set(arr)].length;
        }

        uniqueMorseRepresentations(['gin', 'zen', 'gig', 'msg']);
    })();
</script>
<p>806. 写字符串需要的行数，我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100
    个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， widths[1] 代表 'b' 需要的单位，...， widths[25] 代表 'z'
    需要的单位。 现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。</p>
<script data-msg="806. 写字符串需要的行数">
    (() => {
        function numberOfLines(widths, S){
            const maxLength = 100;
            let rows = 1;
            let sum = 0;
            for (let key of S) {
                const width = widths[key.charCodeAt(0) - 97];
                if (sum + width <= maxLength) {
                    sum += width;
                } else {
                    sum = width;
                    rows++;
                }
            }
            return [rows, sum];
        }

    })();
</script>
<p class="red">811.
    子域名访问计数，一个网站域名，如"discuss.leetcode.com"，包含了多个子域名。作为顶级域名，常用的有"com"，下一级则有"leetcode.com"，最低的一级为"discuss.leetcode.com"。当我们访问域名"discuss.leetcode.com"时，也同时访问了其父域名"leetcode.com"以及顶级域名 "com"。
    给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如："9001 discuss.leetcode.com"。
    接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。</p>
<script data-msg="811. 子域名访问计数">
    (() => {
        function subdomainVisits(cpdomains){
            //  右侧的str最多有多少
            let maxStrLength = 0;
            cpdomains.forEach(item => {
                maxStrLength = Math.max(maxStrLength, item.split('.'));
            });
            cpdomains = cpdomains.map(item => {
                return item.split(' ');
            });
            const map = {};
            while (maxStrLength) {
                maxStrLength--;
                for (let i = 0; i < cpdomains.length; i++) {
                    const item = cpdomains[i];
                    //  'a.b.c.com'
                    const str = item[1];
                    //  com ~ org
                    const key = str.split('.')[maxStrLength];
                    if (!key) {
                        continue;
                    }
                    map[key] = map[key] || {};
                }
            }

        }

        // [["900","google.mail.com"], ["50","yahoo.com"], ["1","intel.mail.com"],[ "5","wiki.org"]]
        //  ["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
    })();
</script>
<p class="red">812. 最大三角形面积，给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。</p>
<script data-msg="812. 最大三角形面积">
    (() => {
        function largestTriangleArea(points){

        }

    })();
</script>
<p>819. 最常见的单词，给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。 题目保证至少有一个词不在禁用列表中，而且答案唯一。
    禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。</p>
<script data-msg="819. 最常见的单词">
    (() => {
        return;

        function mostCommonWord(paragraph, banned){
            const bannedMap = {};
            for (let i = 0; i < banned.length; i++) {
                bannedMap[banned[i]] = true;
            }
            const map = {};
            const arr = paragraph.toLowerCase().replace(/[^a-z]/ig, ',').split(',');
            let max = 0;
            let maxStr = '';
            for (let i = 0; i < arr.length; i++) {
                const item = arr[i];
                if (item === '') {
                    continue;
                }
                if (!bannedMap[item]) {
                    map[item] = map[item] || 0;
                    map[item]++;
                    if (map[item] > max) {
                        maxStr = item;
                        max = map[item];
                    }
                }
            }
            return maxStr;
        }

        const res = mostCommonWord('Bob hit a ball, the hit BALL flew far after it was hit.', ['hit']);
        console.log(res);
    })();
</script>
<p>821. 字符的最短距离，给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。</p>
<script data-msg="821. 字符的最短距离">
    (() => {
        function shortestToChar(S, C){
            const arr = [];
            for (let i = 0; i < S.length; i++) {
                const leftStr = S.slice(0, i + 1);
                const rightStr = S.slice(i);
                const _left = leftStr.lastIndexOf(C);
                const _right = rightStr.indexOf(C);
                const left = _left === -1 ? Infinity : i - _left;
                const right = _right === -1 ? Infinity : _right;
                const min = Math.min(left, right);
                arr.push(min);
            }
            return arr;
        }

        //  S = 'loveleetcode', C = 'e'
        //  [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0];
        shortestToChar('loveleetcode', 'e');

    })();
</script>
<p>824. 山羊拉丁文，</p>
<script data-msg="824. 山羊拉丁文">
    (() => {
        //  略
        function toGoatLatin(S){

        }

    })();
</script>
<p>830. 较大分组的位置，在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 S = "abbxxxxzyy" 中，就含有 "a", "bb", "xxxx", "z" 和 "yy"
    这样的一些分组。 我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。 最终结果按照字典顺序输出。</p>
<script data-msg="830. 较大分组的位置">
    (() => {
        function largeGroupPositions(S){
            let count = 1;
            let charCode = '';
            const arr = [];
            for (let i = 0; i < S.length; i++) {
                if (S[i] === charCode) {
                    count++;
                } else {
                    if (count >= 3) {
                        arr.push([i - count, i - 1]);
                    }
                    charCode = S[i];
                    count = 1;
                }
            }
            if (count >= 3) {
                arr.push([S.length - count, S.length - 1]);
            }
            return arr;
        }

        largeGroupPositions('aaa');

    })();
</script>
<p>832. 翻转图像，给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。
    反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p>
<script data-msg="832. 翻转图像">
    (() => {
        function flipAndInvertImage(A){
            for (let i = 0; i < A.length; i++) {
                const arr = A[i];
                A[i] = arr.reverse();
                for (let j = 0; j < arr.length; j++) {
                    arr[j] = arr[j] ? 0 : 1;
                }
            }
            return A;
        }
    })();
</script>
<p>836. 矩形重叠，矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。
    如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。</p>
<script data-msg="836. 矩形重叠">
    (() => {
        // [x1, y1, x2, y2]
        function isRectangleOverlap(rec1, rec2){
            let top1 = rec1[3];
            let bottom1 = rec1[1];
            let left1 = rec1[0];
            let right1 = rec1[2];

            let top2 = rec2[3];
            let bottom2 = rec2[1];
            let left2 = rec2[0];
            let right2 = rec2[2];

            return (top1 > bottom2 && right1 > left2
                && bottom1 < top2 && left1 < right2
            );
        }

        [0, 0, 2, 2];
        [1, 1, 3, 3];
    })();
</script>
<p>840. 矩阵中的幻方，3 x 3 的幻方是一个填充有从 1 到 9 的不同数字的 3 x 3 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。 给定一个由整数组成的 grid，其中有多少个 3 × 3 的 “幻方”
    子矩阵？（每个子矩阵都是连续的）。 </p>
<script data-msg="840. 矩阵中的幻方">
    (() => {
        return;

        function numMagicSquaresInside(grid){
            if (grid.length < 3 || grid[0].length < 3) {
                return 0;
            }
            //  每行的和
            const sum = 15;
            //  核心
            const centerPoint = 5;

            let count = 0;
            let rowLength = grid[0].length;

            for (let i = 1; i < grid.length - 1; i++) {
                const prevRow = grid[i - 1];
                const row = grid[i];
                const nextRow = grid[i + 1];
                for (let j = 1; j < rowLength - 1; j++) {
                    if (row[j] !== centerPoint) {
                        continue;
                    }
                    if (
                        row[j - 1] + row[j] + row[j + 1] !== sum
                        || prevRow[j - 1] + prevRow[j] + prevRow[j + 1] !== sum
                        || nextRow[j - 1] + nextRow[j] + nextRow[j + 1] !== sum
                        || row[j - 1] + prevRow[j - 1] + nextRow[j - 1] !== sum
                        || row[j] + prevRow[j] + nextRow[j] !== sum
                        || row[j + 1] + prevRow[j + 1] + nextRow[j + 1] !== sum
                        || row[j] + nextRow[j - 1] + prevRow[j + 1] !== sum
                        || row[j] + prevRow[j - 1] + nextRow[j + 1] !== sum
                    ) {
                        continue;
                    }
                    const _arr = [...new Set([row[j], row[j - 1], row[j + 1], nextRow[j], nextRow[j - 1], nextRow[j + 1], prevRow[j], prevRow[j - 1], prevRow[j + 1]])].filter(a => Math.floor(a) === a);
                    if (_arr.length !== 9 || Math.max.apply(null, _arr) !== 9 || Math.min.apply(null, _arr) !== 1) {
                        continue;
                    }
                    count++;
                }
            }
            return count;

        }

        debugger
        numMagicSquaresInside([[4, 3, 8, 4], [9, 5, 1, 9], [2, 7, 6, 2]]);
    })();
</script>
<p>844. 比较含退格的字符串，给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p>
<script data-msg="844. 比较含退格的字符串">
    (() => {
        function backspaceCompare(S, T){
            return getArr(S) === getArr(T);
        }

        function getArr(S){
            let arr = '';
            for (let key of S) {
                if (key === '#') {
                    arr = arr.slice(0, -1);
                } else {
                    arr += key;
                }
            }
            return arr;
        }

    })();
</script>
<p>849. 到最近的人的最大距离，在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。 至少有一个空座位，且至少有一人坐在座位上。 亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。
    返回他到离他最近的人的最大距离。</p>
<script data-msg="849. 到最近的人的最大距离">
    (() => {
        function maxDistToClosest(seats){
            //  个数，活动
            let count = 0;
            //  最大值
            let maxValue = 0;
            //  最大index
            let index = 0;

            let left = null;
            let right = null;

            for (let i = 0; i < seats.length; i++) {
                if (seats[i] === 0) {
                    count++;
                    if (maxValue < count) {
                        index = i;
                        maxValue = count;
                    }
                } else {
                    if (maxValue < count) {
                        index = i;
                        maxValue = count;
                    }
                    count = 0;
                }
                if (seats[0] === 0) {
                    if (seats[i] === 1) {
                        if (left === null) {
                            left = i;
                        }
                    }
                }
                if (seats[seats.length - 1] === 0 && seats[seats.length - 1 - i] === 1) {
                    if (right === null) {
                        right = i;
                    }
                }
            }
            return Math.max(Math.ceil(maxValue / 2), right, left);
        }

        maxDistToClosest([1, 0, 0, 0]);
    })();
</script>
<p>852. 山脉数组的峰顶索引，我们把符合下列属性的数组 A 称作山脉：</p>
<script data-msg="852. 山脉数组的峰顶索引">
    (() => {
        return;

        function peakIndexInMountainArray(A){
            let left = 0;
            let right = A.length - 1;
            let center = Math.floor((left + right) / 2);
            while (left < right) {
                if (A[center] > A[center + 1]) {
                    //  在下坡，要向左
                    right = center;
                } else {
                    left = center;
                }
                center = Math.ceil((left + right) / 2);
                if (center === left || center === right) {
                    return center;
                }
                if (left === right) {
                    return left;
                }
            }
        }

        const res = peakIndexInMountainArray([0, 1, 0]);
        console.log(res);
    })();
</script>
<p>859. 亲密字符串，给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。</p>
<script data-msg="859. 亲密字符串">
    (() => {
        function buddyStrings(A, B){
            if (A.length !== B.length) {return false;}
            const mapA = {};
            let isDifferent = 0;
            let maxLen = 0;
            for (let i = 0; i < A.length; i++) {
                const key = A[i];
                mapA[key] = mapA[key] || 0;
                mapA[key]++;
                maxLen = Math.max(maxLen, mapA[key]);
                if (B[i] !== key) {
                    isDifferent++;
                }
            }
            if (isDifferent > 2) {
                return false;
            }
            if (maxLen < 2 && isDifferent < 2) {
                return false;
            }
            for (let key of B) {
                if (mapA[key] === undefined || mapA[key] === 0) {
                    return false;
                }
                mapA[key]--;
            }
            return true;
        }
    })();
</script>
<p>860. 柠檬水找零</p>
<script data-msg="860. 柠檬水找零">
    (() => {
        function lemonadeChange(bills){
            let residue5 = 0;
            let residue10 = 0;
            for (let i = 0; i < bills.length; i++) {
                if (bills[i] === 5) {
                    residue5++;
                } else if (bills[i] === 10) {
                    if (residue5 > 0) {
                        residue5--;
                        residue10++;
                    } else {
                        return false;
                    }
                } else if (bills[i] === 20) {
                    if (residue5 === 0) {
                        return false;
                    }
                    if (residue10 === 0) {
                        if (residue5 < 3) {
                            return false;
                        }
                        residue5 -= 3;
                    } else {
                        residue10--;
                        residue5--;
                    }
                }
            }
            return true;
        }

        lemonadeChange([5, 5, 10, 20, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 5, 5, 20, 5, 20, 5]);

    })();
</script>
<p>867. 转置矩阵，给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<script data-msg="867. 转置矩阵">
    (() => {
        function transpose(A){
            const row = A.length;
            const col = A[0].length;
            const res = [];
            for (let i = 0; i < col; i++) {
                const item = [];
                for (let j = 0; j < row; j++) {
                    item.push(A[j][i]);
                }
                res.push(item);
            }
            return res;
        }
    })();
</script>
<p>868. 二进制间距，给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。 如果没有两个连续的 1，返回 0 。</p>
<script data-msg="868. 二进制间距">
    (() => {
        function binaryGap(N){
            let max = 0;
            //  前一个1的index
            let prevIndex = null;
            let i = 0;
            while (N) {
                if (N % 2) {
                    if (prevIndex !== null) {
                        max = Math.max(max, i - prevIndex);
                    }
                    prevIndex = i;
                }
                N = Math.floor(N / 2);
                i++;
            }
            return max;
        }

        binaryGap(13);
    })();
</script>
<p class="green">872. 叶子相似的树</p>
<script data-msg="872. 叶子相似的树">
    (() => {
        function leafSimilar(root1, root2){

        }

    })();
</script>
<p>874. 模拟行走机器人</p>
<script data-msg="874. 模拟行走机器人">
    (() => {
        return;

        function robotSim(commands, obstacles){
            if (commands.length === 0) {
                return 0;
            }
            const map = {};
            for (let i = 0; i < obstacles.length; i++) {
                map[obstacles[i]] = true;
            }
            let X = 0;
            let Y = 0;
            //  0⬆️1➡️2⬇️3⬅️
            let turn = 0;
            let max = 0;
            for (let i = 0; i < commands.length; i++) {
                let item = commands[i];
                if (item === -1) {
                    //  右转
                    turn++;
                    if (turn === 4) {
                        turn = 0;
                    }
                } else if (item === -2) {
                    //  左转
                    turn--;
                    if (turn === -1) {
                        turn = 3;
                    }
                } else {
                    while (item--) {
                        let x = X;
                        let y = Y;
                        if (turn === 0) {
                            y++;
                        } else if (turn === 1) {
                            x++;
                        } else if (turn === 2) {
                            y--;
                        } else if (turn === 3) {
                            x--;
                        }
                        //  如果堵住了
                        if (map[`${x},${y}`]) {
                            break;
                        }
                        X = x;
                        Y = y;
                    }
                    max = Math.max(max, X * X + Y * Y);
                }
            }
            return max;
        }

        const res = robotSim([1, 2, -2, 5, -1, -2, -1, 8, 3, -1, 9, 4, -2, 3, 2, 4, 3, 9, 2, -1, -1, -2, 1, 3, -2, 4, 1, 4, -1, 1, 9, -1, -2, 5, -1, 5, 5, -2, 6, 6, 7, 7, 2, 8, 9, -1, 7, 4, 6, 9, 9, 9, -1, 5, 1, 3, 3, -1, 5, 9, 7, 4, 8, -1, -2, 1, 3, 2, 9, 3, -1, -2, 8, 8, 7, 5, -2, 6, 8, 4, 6, 2, 7, 2, -1, 7, -2, 3, 3, 2, -2, 6, 9, 8, 1, -2, -1, 1, 4, 7], [[-57, -58], [-72, 91], [-55, 35], [-20, 29], [51, 70], [-61, 88], [-62, 99], [52, 17], [-75, -32], [91, -22], [54, 33], [-45, -59], [47, -48], [53, -98], [-91, 83], [81, 12], [-34, -90], [-79, -82], [-15, -86], [-24, 66], [-35, 35], [3, 31], [87, 93], [2, -19], [87, -93], [24, -10], [84, -53], [86, 87], [-88, -18], [-51, 89], [96, 66], [-77, -94], [-39, -1], [89, 51], [-23, -72], [27, 24], [53, -80], [52, -33], [32, 4], [78, -55], [-25, 18], [-23, 47], [79, -5], [-23, -22], [14, -25], [-11, 69], [63, 36], [35, -99], [-24, 82], [-29, -98], [-50, -70], [72, 95], [80, 80], [-68, -40], [65, 70], [-92, 78], [-45, -63], [1, 34], [81, 50], [14, 91], [-77, -54], [13, -88], [24, 37], [-12, 59], [-48, -62], [57, -22], [-8, 85], [48, 71], [12, 1], [-20, 36], [-32, -14], [39, 46], [-41, 75], [13, -23], [98, 10], [-88, 64], [50, 37], [-95, -32], [46, -91], [10, 79], [-11, 43], [-94, 98], [79, 42], [51, 71], [4, -30], [2, 74], [4, 10], [61, 98], [57, 98], [46, 43], [-16, 72], [53, -69], [54, -96], [22, 0], [-7, 92], [-69, 80], [68, -73], [-24, -92], [-21, 82], [32, -1], [-6, 16], [15, -29], [70, -66], [-85, 80], [50, -3], [6, 13], [-30, -98], [-30, 59], [-67, 40], [17, 72], [79, 82], [89, -100], [2, 79], [-95, -46], [17, 68], [-46, 81], [-5, -57], [7, 58], [-42, 68], [19, -95], [-17, -76], [81, -86], [79, 78], [-82, -67], [6, 0], [35, -16], [98, 83], [-81, 100], [-11, 46], [-21, -38], [-30, -41], [86, 18], [-68, 6], [80, 75], [-96, -44], [-19, 66], [21, 84], [-56, -64], [39, -15], [0, 45], [-81, -54], [-66, -93], [-4, 2], [-42, -67], [-15, -33], [1, -32], [-74, -24], [7, 18], [-62, 84], [19, 61], [39, 79], [60, -98], [-76, 45], [58, -98], [33, 26], [-74, -95], [22, 30], [-68, -62], [-59, 4], [-62, 35], [-78, 80], [-82, 54], [-42, 81], [56, -15], [32, -19], [34, 93], [57, -100], [-1, -87], [68, -26], [18, 86], [-55, -19], [-68, -99], [-9, 47], [24, 94], [92, 97], [5, 67], [97, -71], [63, -57], [-52, -14], [-86, -78], [-17, 92], [-61, -83], [-84, -10], [20, 13], [-68, -47], [7, 28], [66, 89], [-41, -17], [-14, -46], [-72, -91], [4, 52], [-17, -59], [-85, -46], [-94, -23], [-48, -3], [-64, -37], [2, 26], [76, 88], [-8, -46], [-19, -68]]);
        console.log(res);
    })();
</script>
<p>876. 链表的中间结点，给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p>
<script data-msg="876. 链表的中间结点">
    (() => {
        function middleNode(head){
            let fast = head;
            let slow = head;
            while (fast && fast.next) {
                slow = slow.next;
                fast = fast.next.next;
            }
            return slow;
        }
    })();
</script>
<p>883. 三维形体投影面积，在 N * N 的网格中，我们放置了一些与 x，y，z 三轴对齐的 1 * 1 * 1 立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。
    现在，我们查看这些立方体在 xy、yz 和 zx 平面上的投影。 投影就像影子，将三维形体映射到一个二维平面上。 在这里，从顶部、前面和侧面看立方体时，我们会看到“影子”。 返回所有三个投影的总面积。</p>
<script data-msg="883. 三维形体投影面积">
    (() => {
        function projectionArea(grid){
            const _grid = grid.flat().filter(item => item > 0);
            let xy = _grid.length;
            let xz = 0;
            let maxLen = 0;
            for (let i = 0; i < grid.length; i++) {
                xz += Math.max(...grid[i]);
                maxLen = Math.max(maxLen, grid[i].length);
            }
            let yz = 0;
            while (maxLen--) {
                let max = 0;
                for (let i = 0; i < grid.length; i++) {
                    max = Math.max(grid[i][maxLen] || 0, max);
                }
                yz += max;
            }
            return xy + xz + yz;
        }
        const res = projectionArea([[1, 1, 1], [1, 0, 1], [1, 1, 1]]);

    })();
</script>
</body>
</html>
















