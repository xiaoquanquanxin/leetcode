<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>405-598</title>
    <link rel="stylesheet" href="../css/index.css">
</head>
<body>
<p>405. 数字转换为十六进制数</p>
<script data-msg="405. 数字转换为十六进制数">
    (() => {
        return;

        function toHex(n){
            const arr = ['a', 'b', 'c', 'd', 'e', 'f'];
            let flag = n > 0;
            if (flag) {
                const res = [];
                while (1) {
                    res.unshift(n % 16);
                    if (n < 16) {
                        break;
                    }
                    n = Math.floor(n / 16);
                }
                return res.map(item => {
                    switch (Number(item)) {
                        case 10:
                            item = arr[0];
                            break;
                        case 11:
                            item = arr[1];
                            break;
                        case 12:
                            item = arr[2];
                            break;
                        case 13:
                            item = arr[3];
                            break;
                        case 14:
                            item = arr[4];
                            break;
                        case 15:
                            item = arr[5];
                            break;
                    }
                    return item;
                }).join('');
            }
            let str = (-n - 1).toString(2);
            while (str.length < 32) {
                str = '0' + str;
            }
            let _str = '';
            for (let i = 0; i < str.length; i++) {
                if (str[i] === '0') {
                    _str += '1';
                    continue;
                }
                if (str[i] === '1') {
                    _str += '0';
                }
            }
            return toHex(parseInt(_str, 2));
        }

        const res = toHex(-1);
        console.log(res);
    })();
</script>
<p>409. 最长回文串,给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<script data-msg="409. 最长回文串,给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串">
    (() => {
        return;

        function longestPalindrome(str){
            let sum = 0;
            for (let i = 0; i < str.length; i++) {
                const index = str.lastIndexOf(str[i]);
                //  奇数
                if (index === i) {
                    continue;
                }
                str = str.slice(0, i) + str.slice(i + 1, index) + str.slice(index + 1);
                sum += 2;
                i--;
            }
            if (str.length % 2 === 1) {
                sum++;
            }
            return sum;
        }

        const res = longestPalindrome('dccaccd');
        console.log(res);
    })();
</script>
<p>412. Fizz Buzz.写一个程序，输出从 1 到 n 数字的字符串表示。 1. 如果 n 是3的倍数，输出“Fizz”； 2. 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出
    “FizzBuzz”。</p>
<script data-msg="412. Fizz Buzz.写一个程序，输出从 1 到 n 数字的字符串表示。 1. 如果 n 是3的倍数，输出“Fizz”； 2. 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。">
    (() => {
        return;

        function fizzBuzz(n){
            const arr = [];
            for (let i = 1; i <= n; i++) {
                if (i % 3 !== 0 && i % 5 !== 0) {
                    arr.push(i.toString());
                    continue;
                }
                let str = '';
                if (i % 3 === 0) {
                    str += 'Fizz';
                }
                if (i % 5 === 0) {
                    str += 'Buzz';
                }
                arr.push(str);
            }
            return arr;
        }

        console.log(fizzBuzz(15));
    })();
</script>
<p>414. 第三大的数.给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p>
<script data-msg="414. 第三大的数.给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。">
    (() => {
        return;
        const arr = [1, 2, -2147483648, -2147483648];

        function thirdMax(arr){
            let max = -Infinity;
            let second = -Infinity;
            let third = -Infinity;
            for (let key of arr) {
                if (key > max) {
                    third = second;
                    second = max;
                    max = key;
                    continue;
                }
                if (key > second) {
                    third = second;
                    second = key;
                    continue;
                }
                if (key > third) {
                    third = key;
                }
            }
            if (String.prototype.indexOf.call(arr, third) !== String.prototype.lastIndexOf.call(arr, third)) {
                return max;
            }
            return third;
        }

        const res = thirdMax(arr);
        console.log(res);
    })();
</script>
<p>415. 字符串相加.给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<script data-msg="415. 字符串相加.给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。">
    (() => {
        return;
        const a = '23456768593847569893457968493407923456768593847569893457968493407921';
        const b = '485784039894597807938628094823456768593847569893457968493407948578';

        function addStrings(a, b){
            //  a比较大
            if (b.length > a.length) {
                const c = a;
                a = b;
                b = c;
            }
            let res = '';
            let carryOver = 0;
            while (a.length) {
                let _a = a[a.length - 1];
                let _b = b[b.length - 1] || 0;
                const sum = Number(_a) + Number(_b) + carryOver;
                if (sum > 9) {
                    carryOver = 1;
                } else {
                    carryOver = 0;
                }
                res = sum.toString().slice(-1) + res;
                a = a.slice(0, -1);
                b = b.slice(0, -1);
            }
            return res;
        }

        const res = addStrings(a, b);
        console.log(res);

        console.log(BigInt(a) + BigInt(b));
    })();
</script>
<p>434. 字符串中的单词数.统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<script data-msg="434. 字符串中的单词数.统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。">
    (() => {
        return;

        function countSegments(s){
            let max = 0;
            let current = 0;
            while (s.length) {
                if (s.substring(0, 1) === ' ') {
                    current = 0;
                } else {
                    current++;
                }
                max = Math.max(max, current);
                s = s.slice(1);
            }
            return max;
        }

        const res = countSegments('输入: "Hello, my name is John"');
        console.log(res);
    })();
</script>
<p class="red">437. 路径总和 III</p>
<script></script>
<p>441. 排列硬币.你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数，并且在32位有符号整型的范围内。</p>
<script data-msg="441. 排列硬币.你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数，并且在32位有符号整型的范围内。">
    (() => {
        return;

        function arrangeCoins(n){
            //  个数
            let i = 0;
            //  层数
            let c = 0;
            while (1) {
                c++;
                i += c;
                if (i > n) {
                    return c - 1;
                }
            }
        }

        const res = arrangeCoins(21);
        console.log(res);

    })();
</script>
<p>443. 压缩字符串.给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。</p>
<script data-msg="443. 压缩字符串.给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。">
    (() => {
        return;

        function compress(arr){
            let str = arr.join('');
            arr.length = 0;
            while (str.length) {
                const current = str[0];
                const index = arr.indexOf(current);
                if (index === -1) {
                    arr.push(current);
                } else {
                    if (Number(arr[index + 1])) {
                        arr[index + 1] = (Number(arr[index + 1]) + 1).toString();
                    } else {
                        arr.splice(index + 1, 0, '2');
                    }
                }
                str = str.slice(1);
            }
            let sum = 0;
            arr.forEach(item => {
                sum += item.length;
            });
            return sum;
        }

        const arr = ['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'];
        const res = compress(arr);
        console.log(res);
    })();
</script>
<p class="red">447. 回旋镖的数量,给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。
    找到所有回旋镖的数量。你可以假设 n 最大为
    500，所有点的坐标在闭区间 [-10000, 10000] 中。</p>
<script data-msg="447. 回旋镖的数量,给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。"></script>
<p>448. 找到所有数组中消失的数字,给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。
    您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<script data-msg="448. 找到所有数组中消失的数字,给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。">
    (() => {
        return;

        function findDisappearedNumbers(arr){
            let i = 1;
            let res = [];
            while (i < arr.length) {
                if (arr.indexOf(i) === -1) {
                    res.push(i);
                }
                i++;
            }
            return res;
        }

        const res = findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]);
        console.log(res);
    })();
</script>
<p>453. 最小移动次数使数组元素相等，给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。</p>
<script data-msg="453. 最小移动次数使数组元素相等，给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。">
    (() => {
        return;

        function minMoves(arr){
            const min = Math.min.apply(null, arr);
            const sum = arr.reduce((prev, current) => {
                return prev + current - min;
            }, 0);
            return sum;
        }

        const res = minMoves([1, 1, 2, 6, 7]);
        console.log(res);
    })();
</script>
<p>455. 分发饼干，假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果
    sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<script data-msg="455. 分发饼干，假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。">
    (() => {
        return;

        function findContentChildren(children, pie){
            children = children.sort(sort);
            pie = pie.sort(sort);
            let i = 0;
            let j = 0;
            let s = 0;
            while (i < children.length && j < pie.length) {
                if (pie[j] >= children[i]) {
                    j++;
                    i++;
                    s++;
                } else {
                    i++;
                }
            }
            return s;
        }

        //  从大到小排序
        function sort(a, b){
            return b - a;
        }

        const res = findContentChildren([1, 2], [1, 2, 3]);
        console.log(res);
    })();
</script>
<p>459. 重复的子字符串，给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<script data-msg="459. 重复的子字符串，给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。">
    (() => {
        return;

        function repeatedSubstringPattern(str){
            let i = 1;
            let len = str.length;
            while (i < Math.floor(len / 2) + 1) {
                //  如果除不尽
                if (len % 2 !== 0) {
                    i++;
                    continue;
                }
                let _str = ''.padEnd(len, str.slice(0, i));
                if (_str === str) {
                    return true;
                }
                i++;
            }
            return false;
        }

        const str = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';
        console.log(repeatedSubstringPattern(str));
    })();
</script>
<p>461. 汉明距离，两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<script data-msg="461. 汉明距离，两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。">
    (() => {
        return;

        function hammingDistance(a, b){
            let bin = a^b;
            let s = 0;
            while (bin) {
                if (bin % 2 === 1) {
                    s++;
                }
                bin = Math.floor(bin / 2);
            }
            return s;
        }

        const res = hammingDistance(5, 4);
        console.log(res);
    })();
</script>
<p>463. 岛屿的周长，给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
    网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1
    的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<script data-msg="463. 岛屿的周长，给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。">
    (() => {
        return;

        function islandPerimeter(grid){
            let c = 0;
            //  层
            for (let i = 0; i < grid.length; i++) {
                //  列
                for (let j = 0; j < grid[i].length; j++) {
                    //  是陆地
                    if (grid[i][j] === 1) {
                        //  判断上下左右，如果是零，则+1
                        //  左右一定有
                        if (grid[i][j - 1] !== 1) {
                            c++;
                        }
                        if (grid[i][j + 1] !== 1) {
                            c++;
                        }
                        if (!grid[i - 1] || grid[i - 1][j] !== 1) {
                            c++;
                        }
                        if (!grid[i + 1] || grid[i + 1][j] !== 1) {
                            c++;
                        }
                    }
                }
            }
            return c;
        }

        const grid = [
            [0, 1, 0, 0],
            [1, 1, 1, 0],
            [0, 1, 0, 0],
            [1, 1, 0, 0]];
        const res = islandPerimeter(grid);
        console.log(res);
    })();
</script>
<p>475. 供暖器，冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。
    所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。</p>
<script data-msg="475. 供暖器，冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。">
    (() => {
        return;
        //  暴力循环法，不好
        // function findRadius(houses, heaters){
        //     const range = [];
        //     let r = 1;
        //     while (1) {
        //         range.length = 0;
        //         for (let i = 0; i < heaters.length; i++) {
        //             range.push([heaters[i] - r, heaters[i] + r]);
        //         }
        //         let isInNum = 0;
        //         for (let i = 0; i < houses.length; i++) {
        //             for (let j = 0; j < range.length; j++) {
        //                 if (houses[i] >= range[j][0] && houses[i] <= range[j][1]) {
        //                     isInNum++;
        //                     break;
        //                 }
        //             }
        //         }
        //         if (isInNum === houses.length) {
        //             return r;
        //         }
        //         r++;
        //     }
        // }

        //  找到每个房子最近的那个，再获得其中最远的那个
        // function findRadius(houses, heaters){
        //     houses = houses.sort(sort);
        //     heaters = heaters.sort(sort);
        //     let max = 1;
        //     houses.forEach(item => {
        //         for (let i = 0; i < heaters.length; i++) {
        //             heaters[i + 1] = heaters[i + 1] || Infinity;
        //             if (Math.abs(item - heaters[i]) < Math.abs(item - heaters[i + 1])) {
        //                 max = Math.max(max, Math.abs(item - heaters[i]));
        //                 return;
        //             }
        //         }
        //     });
        //     return max;
        // }

        //  双指针法
        function findRadius(houses, heaters){
            let max = 1;
            let i = 0;
            let j = 0;
            houses = houses.sort(sort);
            heaters = heaters.sort(sort);
            while (i < houses.length && j < heaters.length) {
                heaters[j + 1] = heaters[j + 1] || Infinity;
                //  如果左侧没有暖气
                if (houses[i] <= heaters[j]) {
                    max = Math.max(max, Math.abs(houses[i] - heaters[j]));
                    i++;
                    continue;
                }
                //  如果左右都有暖气
                if (houses[i] > heaters[j]) {
                    max = Math.max(max, Math.min(Math.abs(houses[i] - heaters[j]), Math.abs(houses[i] - heaters[j + 1])));
                    i++;
                    //  如果左面的比右面的距离大
                    if (Math.abs(houses[i] - heaters[j]) >= Math.abs(houses[i] - heaters[j + 1])) {
                        j++;
                    }
                }
                //  右侧一定有暖气
            }
            return max;
        }

        function sort(a, b){
            return a - b;
        }

        const houses = [-5, 2, 10, 14];
        const heaters = [1, 11];
        const res = findRadius(houses, heaters);
        console.log(res);
    })();
</script>
<p>476. 数字的补数。给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p>
<script data-msg="476. 数字的补数。给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。">
    (() => {
        return;

        function findComplement(num){
            const b_num = num.toString(2);
            let str = '';
            for (let i = 0; i < b_num.length; i++) {
                str += (Number(b_num[i]) === 0) ? 1 : 0;
            }
            return parseInt(str, 2);
        }

        console.log(findComplement(2));
    })();
</script>
<p>482. 密钥格式化，有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。 给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K
    个字符；而第一个分组中，至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。 给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<script data-msg="482. 密钥格式化，有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。 给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符；而第一个分组中，至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。 给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。">
    (() => {
        return;

        function licenseKeyFormatting(S, K){
            let str = S.toUpperCase().split('-').join('');
            let res = '';
            while (str.length > K) {
                const current = str.substr(-K);
                res = `${current}-${res}`;
                str = str.slice(0, str.length - K);
            }
            res = `${str}-${res}`;
            if (res[res.length - 1] === '-') {
                res = res.slice(0, res.length - 1);
            }
            return res;
        }

        // const res = licenseKeyFormatting('5F3Z-2e-9-w', 4);
        const res = licenseKeyFormatting('2-5g-3-J', 2);
        console.log(res);
    })();
</script>
<p>485. 最大连续1的个数，给定一个二进制数组， 计算其中最大连续1的个数。</p>
<script data-msg="485. 最大连续1的个数，给定一个二进制数组， 计算其中最大连续1的个数。">
    (() => {
        return;

        function findMaxConsecutiveOnes(nums){
            let max = 0;
            let sum = 0;
            nums.reduce((prev, current) => {
                if (prev === 0) {
                    sum = 0;
                }
                if (current === 1) {
                    sum++;
                    max = Math.max(max, sum);
                }
                return current;
            }, 0);
            return max;
        }

        const res = findMaxConsecutiveOnes([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
        console.log(res);

    })();
</script>
<p>492. 构造矩形，作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 1.
    你设计的矩形页面必须等于给定的目标面积。 2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。 3. 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。</p>
<script data-msg="492. 构造矩形，作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 1. 你设计的矩形页面必须等于给定的目标面积。 2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。 3. 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。">
    (() => {
        return;
        //  给定的面积不大于 10,000,000 且为正整数。
        // 你设计的页面的长度和宽度必须都是正整数
        function constructRectangle(area){
            const sqrt = Math.sqrt(area);
            //  是正方形
            if (sqrt % 1 === 0) {
                return [sqrt, sqrt];
            }
            let w = Math.floor(sqrt);
            let l = 0;
            while (w > 1) {
                l = area / w;
                if (l % 1 === 0) {
                    return [w, l];
                }
                w--;
            }
            return [1, area];
        }

        const res = constructRectangle(1602);
        console.log(res);
    })();
</script>
<p>496. 下一个更大元素 I，给定两个 没有重复元素 的数组 nums1
    和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出
    -1 。</p>
<script data-msg="496. 下一个更大元素 I，给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。">
    (() => {
        // return;
        //  暴力法
        // function nextGreaterElement(nums1, nums2){
        //     const res = new Array(nums1.length);
        //     nums1.forEach((item, i) => {
        //         const index = nums2.indexOf(item);
        //         const greatThan = nums2.slice(index).find(_item => {
        //             return _item > item;
        //         });
        //         if (!greatThan) {
        //             res[i] = -1;
        //             return;
        //         }
        //         res[i] = greatThan;
        //     });
        //     return res;
        // }

        return;

        //  hash 法
        function nextGreaterElement(nums1, nums2){
            console.log(nums1);
            console.log(nums2);
            const hash = {};
            nums2.forEach((item, index) => {
                hash[item] = -1;
                //  剩余的数组
                const reArr = nums2.slice(index + 1);
                //  之后第一个大的index
                let _index = reArr.find(_item => {
                    return _item > item;
                });
                //  如果没有
                if (_index === undefined) {
                    return;
                }
                hash[item] = _index;
            });
            console.log(hash);
            const arr = new Array(nums1.length);
            // debugger
            nums1.forEach((item, index) => {
                arr[index] = hash[item];
            });
            return arr;
        }

        const nums1 = [4, 1, 2];
        const nums2 = [1, 3, 4, 2];
        //
        // const nums1 = [2, 4];
        // const nums2 = [1, 2, 3, 4];

        const res = nextGreaterElement(nums1, nums2);
        console.log(res);
    })();
</script>
<p>500. 键盘行，给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</p>
<script data-msg="500. 键盘行，给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。">
    (() => {
        //  略
    })();
</script>
<p class="red">501. 二叉搜索树中的众数，给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST
    有如下定义：，结点左子树中所含结点的值小于等于当前结点的值，结点右子树中所含结点的值大于等于当前结点的值，左子树和右子树都是二叉搜索树</p>
<script data-msg=">501. 二叉搜索树中的众数，给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义：，结点左子树中所含结点的值小于等于当前结点的值，结点右子树中所含结点的值大于等于当前结点的值，左子树和右子树都是二叉搜索树">
    (() => {
        return;

        //  中序遍历，然后就是一个有序数组了，不需要额外的空间，中序遍历难，那就快排递归
        function findMode(root){
            console.log(root);
            root = quickSort(root);
            console.log(root);
            let max = 0;
            let item = null;
            let sum = 0;

            for (let i = 0; i < root.length; i++) {
                if (root[i] === item) {
                    sum++;
                    if (sum >= max) {
                        max = sum;
                    }
                    continue;
                }
                item = root[i];
                sum = 1;
            }
            return max;
        }

        function quickSort(arr){
            if (arr.length <= 1) {
                return arr;
            }
            let left = [];
            let right = [];
            let middleArr = [];
            let middle = Math.floor(arr.length / 2);
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] < arr[middle]) {
                    left.push(arr[i]);
                } else if (arr[i] > arr[middle]) {
                    right.push(arr[i]);
                } else {
                    middleArr.push(arr[i]);
                }
            }
            return quickSort(left).concat(middleArr).concat(quickSort(right));
        }

        const res = findMode([1, null, 2, 2]);
        console.log(res);
    })();
</script>
<p>504. 七进制数，给定一个整数，将其转化为7进制，并以字符串形式输出。</p>
<script data-msg="504. 七进制数，给定一个整数，将其转化为7进制，并以字符串形式输出。">
    (() => {
        return;

        function convertToBase7(num){
            const arr = [];
            while (num > 0) {
                const res = num % 7;
                arr.unshift(res);
                num = Math.floor(num / 7);
            }
            return arr.join('');
        }

        const res = convertToBase7(100);
        console.log(res);
    })();
</script>
<p>506. 相对名次，给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（"Gold Medal", "Silver Medal", "Bronze
    Medal"）。(注：分数越高的选手，排名越靠前。)</p>
<script data-msg="506. 相对名次，给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（Gold Medal）。(注：分数越高的选手，排名越靠前。)">
    (() => {
        return;

        function findRelativeRanks(list){
            const price = ['Gold Medal', 'Silver Medal', 'Bronze Medal'];
            let len = price.length;
            while (len) {
                const min = Math.min.apply(null, list);
                const index = list.indexOf(min);
                list.splice(index, 1);
                len--;
            }
            return price.concat(list);
        }

        const res = findRelativeRanks([5, 4, 3, 2, 1]);
        console.log(res);
    })();
</script>
<p>507. 完美数，对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False</p>
<script data-msg="507. 完美数，对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False">
    (() => {
        return;

        function checkPerfectNumber(num){
            const sqrt = Math.sqrt(num);
            let i = 1;
            let sum = 0;
            while (i <= sqrt) {
                if (num % i === 0) {
                    console.log(i, num / i);
                    sum += i;
                    sum += num / i;
                }
                i++;
            }
            if (sqrt % 1 === 0) {
                sum -= sqrt;
            }
            sum /= 2;
            console.log(sum);
            return sum === num;
        }

        const res = checkPerfectNumber(18);
        console.log(res);
    })();
</script>
<p>509. 斐波那契数</p>
<script data-msg="509. 斐波那契数">
    (() => {
        return;
        // function fib(n){
        //     if (n <= 2) {
        //         return 1;
        //     }
        //     return fib(n - 1) + fib(n - 2);
        // }

        // function fib(n){
        //     let a = 0;
        //     let b = 1;
        //     let c;
        //     while (n) {
        //         c = a;
        //         a = b;
        //         b = c + b;
        //         n--;
        //     }
        //     return a;
        // }

        function fib(n, a, b){
            a = a || 0;
            b = b || 1;
            if (n <= 2) {
                return a + b;
            }
            return fib(--n, b, a + b);
        }

        for (let i = 1; i < 10; i++) {
            const res = fib(i);
            console.log(res);
        }

    })();
</script>
<p>520. 检测大写字母，给定一个单词，你需要判断单词的大写使用是否正确。
    我们定义，在以下情况时，单词的大写用法是正确的：
    全部字母都是大写，比如"USA"。
    单词中所有字母都不是大写，比如"leetcode"。
    如果单词不只含有一个字母，只有首字母大写， 比如 "Google"。
    否则，我们定义这个单词没有正确使用大写字母。</p>
<script data-msg="520. 检测大写字母，给定一个单词，你需要判断单词的大写使用是否正确。我们定义，在以下情况时，单词的大写用法是正确的：   全部字母都是大写，比如'USA'。 单词中所有字母都不是大写，比如'leetcode'。 如果单词不只含有一个字母，只有首字母大写， 比如 'Google'。 否则，我们定义这个单词没有正确使用大写字母。">
    (() => {
        return;

        // function detectCapitalUse(word){
        //     let n = word.length;
        //     let res = 0;
        //     while (n--) {
        //         //  是小写
        //         if (word[n].charCodeAt(0) >= 97) {
        //
        //         } else {
        //             res++;
        //         }
        //     }
        //     if (res === word.length || res === 0) {
        //         return true;
        //     }
        //     if (res === 1 && word[0].charCodeAt(0) < 97) {
        //         return true;
        //     }
        //     return false;
        // }

        //
        var detectCapitalUse = function (word){
            let reg1 = /^[A-Z]*$/;
            let reg2 = /^[A-Z][a-z]*$/;
            let reg3 = /^[a-z]*$/;
            return reg1.test(word) || reg2.test(word) || reg3.test(word);
        };

        const res = detectCapitalUse('FFF');
        console.log(res);
    })();
</script>
<p>530. 二叉搜索树的最小绝对差，给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<script data-msg="530. 二叉搜索树的最小绝对差，给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。">
    (() => {
        return;

        function getMinimumDifference(list){
            list = list.sort((a, b) => a - b);
            let min = Infinity;
            list.reduce((prev, current) => {
                let diff = current - prev;
                if (diff < min) {
                    min = Infinity;
                }
                return current;
            });
            return min;
        }

        console.log();

    })();
</script>
<p class="red">532. 数组中的K-diff数对，给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j
    都是数组中的数字，且两数之差的绝对值是 k.</p>
<script data-msg="532. 数组中的K-diff数对，给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.">
    (() => {
        return;

        //  自己写的这个还行吧
        function findPairs(list, k){
            if (k < 0) {
                return 0;
            }
            const map = {};
            let sum = 0;
            list.forEach(key => {
                map[key] = map[key] || 0;
                if (k !== 0) {
                    if (map[key - k] || map[key + k]) {
                        //  保证是第一次，注意这时候我还没有++
                        if (map[key] === 0) {
                            sum++;
                        }
                    }
                } else {
                    if (map[key] === 1) {
                        sum++;
                    }
                }
                map[key]++;
            });
            return sum;
        }

        console.log(findPairs([3, 1, 4, 1, 5], 2));
        console.log(findPairs([1, 2, 3, 4, 5], 1));
        console.log(findPairs([1, 3, 1, 5, 4], 0));
        console.log(findPairs([1, 3, 1, 5, 4, 3, 4, 2, 1, 1, 1, 1], 0));

        // function fn(arr, n){
        //     const hash = {};
        //     let sum = 0;
        //     arr.forEach(key => {
        //         hash[key] = hash[key] || 0;
        //         if (hash[n - key]) {
        //             if (hash[key] === 1) {
        //                 sum++;
        //             }
        //         }
        //         hash[key]++;
        //     });
        //     // console.log(hash);
        //     return sum;
        // }

        // const arr = [1, 2, 3, 3, 3, 4, 2, 5];
        // const res = fn(arr, 4);
        // console.log(res);
    })();
</script>
<p class="red">538. 把二叉搜索树转换为累加树，给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<script data-msg="538. 把二叉搜索树转换为累加树">
    (() => {

    })();
</script>
<p>541. 反转字符串 II，给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k
    个，则反转前 k 个字符，其余字符保持原样。</p>
<script data-msg="541. 反转字符串 II">
    (() => {
        return;

        function reverseStr(s, k){
            let str = '';
            for (let i = 0; i < s.length; i += k) {
                let _s = s.slice(i, i + k);
                if (i % (k * 2) === 0) {
                    _s = _s.split('').reverse().join('');
                }
                str += _s;
            }
            return str;
        }

        const str = reverseStr('abcdefg', 2);
        console.log(str);

    })();
</script>
<p class="red">543. 二叉树的直径，给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<script data-msg="543. 二叉树的直径">
    (() => {
        function diameterOfBinaryTree(root){
            function getNode(node){
                if (!node.value) {
                    return;
                }
                if (!node.left && !node.right) {
                    sum++;
                    return;
                }
                if (node.left || node.right) {
                    getNode(node.left);
                    getNode(node.right);
                }

            }

            let sum = 0;

            getNode(root);
        }
    })();
</script>
<p>551. 学生出勤记录 I</p>
<script data-msg="551. 学生出勤记录 I">
    (() => {
        return;

        function checkRecord(str){
            let l = true;
            let a = true;
            const arr = str.split('');
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === 'A') {
                    a = false;
                }
                if (arr[i - 2] === 'L' && arr[i - 1] === 'L' && arr[i] === 'L') {
                    l = false;
                }
                if (!a && !l) {
                    return false;
                }
            }
            return true;
        }

        console.log(checkRecord('PPALLP'));
        console.log(checkRecord('PPALLL'));
    })();
</script>
<p>557. 反转字符串中的单词 III，给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<script data-msg="557. 反转字符串中的单词 III">
    (() => {
        return;

        function reverseWords(str){
            const arr = str.split(' ');
            const res = [];
            for (let i = 0; i < arr.length; i++) {
                res.push(arr[i].split('').reverse().join(''));
            }
            return res.join(' ');
        }

        console.log(reverseWords('Let\'s take LeetCode contest'));
        console.log(reverseWords('s\'teL ekat edoCteeL tsetnoc'));
    })();
</script>
<p>559. N叉树的最大深度，给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<script data-msg="N叉树的最大深度">
    (() => {
        return;

        function maxDepth(root){
            let max = 0;

            function setDepth(root, n){
                root.depth = n;
                max = Math.max(max, root.depth);
                if (root.children) {
                    root.children.forEach(item => {
                        setDepth(item, root.depth + 1);
                    });
                }

            }

            setDepth(root, 1);
            return max;
        }
    })();
</script>
<p>561. 数组拆分 I，给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<script data-msg="561. 数组拆分 I">
    (() => {
        function arrayPairSum(list){
            if (list % 2) {
                throw new Error('错误的数据');
            }
            list = list.sort((a, b) => a - b);
            const map = {};
            for (let i = 0; i < list.length; i += 2) {
                map[i] = [list[i], list[i + 1]];
            }
            return map;
        }

    })();
</script>
<p>563. 二叉树的坡度，给定一个二叉树，计算整个树的坡度。 一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。 整个树的坡度就是其所有节点的坡度之和。</p>
<script data-msg="563. 二叉树的坡度">
    (() => {

        function findTilt(root){
            let leftSum = 0;
            let rightSum = 0;

            function fn(node){
                if (!node.value) {
                    return;
                }
                if (node.left) {
                    leftSum += fn(node.left);
                }
                if (node.right) {
                    rightSum += fn(node.right);
                }
                return node.value;
            }

            fn(root);

            return Math.abs(leftSum - rightSum);
        }

    })();
</script>
<p>566.重塑矩阵</p>
<script data-msg="566.重塑矩阵">
    (() => {
        return;

        function matrixReshape(nums, r, c){
            let len = nums.length * nums[0].length;
            //  原数组
            if (r * c !== len) {
                return nums;
            }
            const arr = [];
            for (let item of nums) {
                arr.push(...item);
            }
            const res = [];
            for (let i = 0; i < r; i++) {
                res.push(arr.splice(0, c));
            }
            return res;
        }

        const res = matrixReshape([[1, 2], [3, 4]], 2, 2);
        // const res = matrixReshape([[1, 2, 3, 4]], 2, 2);
        console.log(res);
    })();
</script>
<p class="red">572. 另一个树的子树，给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<script data-msg="572. 另一个树的子树">
    (() => {
        function isSubtree(s, t){
            // if( )
        }

    })();
</script>
<p>575. 分糖果，给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<script data-msg="575. 分糖果">
    (() => {
        return;

        function distributeCandies(candies){
            return Math.min([...new Set(candies)].length, candies.length / 2);
        }

        const res = distributeCandies([1, 1, 2, 2, 3, 3]);
        console.log(res);
    })();
</script>
<p class="orange">581. 最短无序连续子数组，给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。</p>
<script data-msg="581. 最短无序连续子数组">
    (() => {
        return;

        //  ⚠️思路：假设中间有一个子数组，把它往两边扩张，那么需要从左到右推右边，从右到左推左边
        function findUnsortedSubarray(list){
            let min = Infinity;
            let left = null;
            for (let i = list.length - 1; i >= 0; i--) {
                min = Math.min(min, list[i]);
                if (min >= list[i]) {
                    continue;
                }
                left = i;
            }
            let max = -Infinity;
            let right = null;
            for (let i = 0; i < list.length; i++) {
                max = Math.max(list[i], max);
                if (max <= list[i]) {
                    continue;
                }
                right = i;
            }
            if (left === null || right === null) {
                return 0;
            }
            console.log(left, right);
            return right - left + 1;
        }

        const res = findUnsortedSubarray([2, 4, 6, 7, 5, 1, 4, 8, 10, 9, 15]);
        // const res = findUnsortedSubarray([1, 2, 3, 4]);
        // const res = findUnsortedSubarray([2, 1]);
        console.log(res);

    })();
</script>
<p class="red">589. N叉树的前序遍历，给定一个 N 叉树，返回其节点值的前序遍历。</p>
<script data-msg="589. N叉树的前序遍历">
    (() => {
        // function preorder(root){
        //     const arr = [];
        //
        //     function preorderFn(node){
        //         if (!node.value) {
        //             return;
        //         }
        //         const left = preorderFn(node.left);
        //         if (left) {
        //             arr.push(left);
        //         }
        //         const right = preorderFn(node.right);
        //         if (left) {
        //             arr.push(right);
        //         }
        //         arr.push(node.value);
        //         return node.value;
        //     }
        //
        //     preorderFn(root);
        //     return arr;
        // }

        var preorder2 = function (root){
            if (!root) return [];

            var res = [], arr = [root];
            while (arr.length) {
                var current = arr.pop();
                res.push(current.val);

                for (var i = current.children.length - 1; i >= 0; i--) {
                    arr.push(current.children[i]);
                }
            }
            return res;
        };

    })();
</script>
<p class="red">590. N叉树的后序遍历</p>
<script data-msg="590. N叉树的后序遍历"></script>
<p class="orange">594. 最长和谐子序列，和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。 现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<script data-msg="594. 最长和谐子序列">
    (() => {
        return;
        //  这是另一个题目了
        // function findLHS(nums){
        //     //  前一个数的结果
        //     let preRes = 0;
        //     let start = 0;
        //     //  最大的子串长度
        //     let maxLength = 0;
        //     // debugger;
        //     //  从左到右
        //     for (let i = 0; i < nums.length; i++) {
        //         //  如果绝对值的差大于1
        //         if (Math.abs(nums[i] - nums[i - 1]) > 1 || isNaN(nums[i - 1])) {
        //             maxLength = Math.max(1, maxLength);
        //             preRes = 0;
        //             start = i;
        //             continue;
        //         }
        //         const _preRes = preRes;
        //         preRes = nums[i] - nums[i - 1];
        //         //  如果连续的递增或递减
        //         if (nums[i] - nums[i - 1] === _preRes) {
        //             start = i;
        //             continue;
        //         }
        //         //  如果是波动的
        //         maxLength = Math.max(i - start, maxLength);
        //     }
        //     return maxLength;
        // }

        //  遍历两遍
        // function findLHS(list){
        //     const hash = {};
        //     let max = 0;
        //     for (let i = 0; i < list.length; i++) {
        //         hash[list[i]] = hash[list[i]] || 0;
        //         hash[list[i]]++;
        //     }
        //     for (let key in hash) {
        //         if (!hash.hasOwnProperty(key)) {
        //             continue;
        //         }
        //         if (hash[Number(key) + 1] !== undefined) {
        //             max = Math.max(hash[key] + hash[Number(key) + 1], max);
        //         }
        //     }
        //     return max;
        // }

        //  🌟好算法
        function findLHS(list){
            const hash = {};
            let max = 0;
            for (let i = 0; i < list.length; i++) {
                const key = list[i];
                const preKey = +key - 1;
                const nextKey = +key + 1;
                hash[key] = hash[key] || 0;
                hash[key]++;
                if (hash[preKey] !== undefined) {
                    max = Math.max(hash[key] + hash[preKey], max);
                }
                if (hash[nextKey] !== undefined) {
                    max = Math.max(hash[key] + hash[nextKey], max);
                }
            }
            return max;
        }

        // const res = findLHS([1, 3, 2, 2, 5, 2, 3, 7]);
        // const res = findLHS([1, 3, 5, 7, 9, 11, 13, 15, 17]);
        // const res = findLHS([1, 1, 1, 1]);
        // const res = findLHS([1, 2, 2, 1]);
        // const res = findLHS([3751, 8640, -5020, 1851, 4196, 2738, 3730, 1258, -8906, 8825, 3392, 9015, 8184, 6439, 7219, -95, 3511, 3573, -1304, 4200, 2009, -934, 4001, 9269, 8599, 3440, 8419, 1101, 8700, 1228, 6962, 5431, 9593, 5449, -3994, 1873, 5198, 6912, -7428, 9610, 9824, 6694, 1417, -5633, -5526, 5608, 5141, 816, 7380, 9444, 4948, 9252, -386, 3144, 7701, 4867, 6059, 5210, 9669, 4139, -3215, 493, 2527, 8031, 6828, 9554, 8515, 2065, -1157, 3547, 3317, 5042, 1454, -2964, 9130, 6430, 9539, 4500, 8539, 4814, 9363, 2215, 9256, 7021, 4934, 9772, 1241, 7628, 2035, 189, 5082, 5010, 8862]);
        const res = findLHS([1, 2, 2, 3, 4, 5, 1, 1, 1, 1]);

        console.log(res);
    })();
</script>
<p>598. 范围求和 II，给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 <= i < a
    以及 0 <= j < b 的元素 M[i][j] 的值都增加 1。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>
<script data-msg="598. 范围求和 II">
    (() => {
        return;

        function maxCount(m, n, ops){
            if (ops.length === 0) {
                return m * n;
            }
            let cols = Infinity;
            let row = Infinity;
            for (let i = 0; i < ops.length; i++) {
                cols = Math.min(ops[i][0], cols);
                row = Math.min(ops[i][1], row);
            }
            return cols * row;
        }

        const res = maxCount(3, 3, [[2, 2], [3, 3]]);
        console.log(res);
    })();
</script>
</body>
</html>





















