<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>367-559</title>
    <link rel="stylesheet" href="../css/index.css">
</head>
<body>
<p>367. 有效的完全平方数</p>
<p>💡有技巧，数学方法也</p>
<script data-msg="367. 有效的完全平方数">
    (() => {
        //  二刷，二分法
        function isPerfectSquare(n){
            let left = 1;
            let right = n;
            while (left < right) {
                const middle = (left + right) >> 1;
                //  这里有可能溢出
                const mult = middle * middle;
                if (mult === n) {
                    return true;
                } else if (mult > n) {
                    right = middle - 1;
                } else {
                    left = middle + 1;
                }
            }
            return (left * left === n);
        }

        //  奇技淫巧
        function isPerfectSquare(n){
            return (n ** 0.5) % 1 === 0;
        }

        //  数学，1 + 3 + 5 + 7 + 2n-1 的和为完全平方数
        //  有可能超时
        function isPerfectSquare(n){
            let sum = 1;
            let prev = 1;
            while (sum < n) {
                prev += 2;
                sum += prev;
            }
            return (sum === n);
        }
    })();
</script>
<br>
<p class="sky">371. 两整数之和</p>
<p>一看就是位运算</p>
<script data-msg="371. 两整数之和">
    (() => {
        //  二刷
        function getSum(a, b){
            if (b === 0) {
                return a;
            }
            //  异或，对于错位不想等的 == 1
            const xor = a^b;
            //  且，2个1进位
            const and = (a&b) << 1;
            return getSum(xor, and);
        }
    })();
</script>
<br>
<p>374. 猜数字大小</p>
<p>一看就是二分</p>
<script data-msg="374. 猜数字大小">
    (() => {

        const res = getValue(2132, 1321);

        //  二分
        function getValue(n, guessValue){
            let min = 1;
            let max = n;
            while (true) {
                let center = Math.floor((min + max) / 2);
                if (center === guessValue) {
                    return center;
                }
                //  需要减小
                if (center > guessValue) {
                    max = center - 1;
                }
                //  需要增加
                if (center < guessValue) {
                    min = center + 1;
                }
            }
        }

        //  二刷
        function guessNumber(n){
            let left = 1;
            let right = n;
            while (left < right) {
                const middle = (left + right) >>> 1;
                switch (guess(middle)) {
                    case 0:
                        return middle;
                    case 1:
                        left = middle + 1;
                        break;
                    case -1:
                        right = middle;
                        break;
                }
            }
            return left;
        }
    })();
</script>
<br>
<p>383. 赎金信</p>
<p>认真，和以前的重复了</p>
<script data-msg="383. 赎金信">
    (() => {
        const a = canConstruct('a', 'b');
        const b = canConstruct('aa', 'ab');
        const c = canConstruct('aa', 'aab');

        function canConstruct(a, b){
            const mapA = {};
            b.split('').forEach(item => {
                mapA[item] = mapA[item] || 0;
                mapA[item]++;
            });
            let arr = a.split('');
            for (let i = 0; i < arr.length; i++) {
                if (mapA[arr[i]] === undefined || mapA[arr[i]] === 0) {
                    return false;
                }
                mapA[arr[i]]--;
            }
            return true;
        }

        //  二刷
        function canConstruct(ransomNote, magazine){
            if (ransomNote.length > magazine.length) {
                return false;
            }
            const map = new Map();
            ransomNote = ransomNote.split('');
            for (let key of ransomNote) {
                const value = map.get(key) || 0;
                map.set(key, value + 1);
            }
            magazine = magazine.split('');
            for (let key of magazine) {
                const value = map.get(key);
                if (!value) {
                    continue;
                }
                if (value === 1) {
                    map.delete(key);
                } else {
                    map.set(key, value - 1);
                }
                //  兑换完了
                if (!map.size) {
                    return true;
                }
            }
            return !map.size;
        }

        canConstruct('aa', 'aab');
    })();
</script>
<br>
<p>387. 字符串中的第一个唯一字符</p>
<p>⚠️审题，返回index</p>
<script data-msg="387. 字符串中的第一个唯一字符">
    (() => {
        const a = firstUniqChar('leetcode');
        const b = firstUniqChar('loveleetcode');

        function firstUniqChar(str){
            const map = {};
            for (let i = 0; i < str.length; i++) {
                map[str[i]] = map[str[i]] || 0;
                map[str[i]]++;
                if (map[str[i]] > 1) {
                    const char = str[i];
                    str = str.replace(new RegExp(char, 'ig'), ' ');
                }
            }
            return str.indexOf(str.trim()[0]);
        }

        //  二刷
        function firstUniqChar(str){
            const map = new Map();
            const indexList = {};
            for (let i = 0, len = str.length; i < len; i++) {
                const key = str.charAt(i);
                const count = map.get(key) || 0;
                map.set(key, count + 1);
                if (indexList[key] === undefined) {
                    indexList[key] = i;
                }
            }
            for (let key of map) {
                if (key[1] === 1) {
                    return indexList[key[0]];
                }
            }
            return -1;
        }

        firstUniqChar('leetcode');

    })();
</script>
<br>
<p class="sky">389. 找不同</p>
<p>⚠️位运算，异或两次为0</p>
<script data-msg="389. 找不同">
    (() => {
        const a = 'abd';
        const b = 'abcd';

        const res = findTheDifference(a, b);
//        console.log(res);

        // function findTheDifference(s, t){
        //     for (let i = 0; i < s.length; i++) {
        //         t = t.replace(new RegExp(s[i], 'ig'), '');
        //     }
        //     return t;
        // }

        //  位运算
        function findTheDifference(s, t){
            const total = s + t;
            let i = 0;
            let res = 0;
            while (i < total.length) {
                res ^= total.charCodeAt(i);
                console.log(res);
                i++;
            }
            return String.fromCharCode(res);
        }

        //  二刷
        function findTheDifference(s, t){
            const str = s + t;
            let xor = 0;
            for (let i = 0, len = str.length; i < len; i++) {
                xor ^= str.charCodeAt(i);
            }
            return String.fromCodePoint(xor);
        }
    })();
</script>
<br>
<p>392. 判断子序列</p>
<p>while循环，双指针，贪心</p>
<script data-msg="392. 判断子序列">
    (() => {
        //  就你叫贪心算法啊？双指针法由于要遍历过多的t，不好
        //  t长，s短
        function isSubsequence(t, s){
            let index = 0;
            for (let i = 0; i < s.length; i++) {
                index = t.indexOf(s[i], index);
                if (index === -1) {
                    return false;
                }
                console.log(index);
            }
            return true;
        }

        const t = 'feawfgnajwiohgobgouhovnbfrjfiebhjanbjfnnjfanruiqouhjnmfjighobnfnrmbnefnjmbaefnmnjafjbnfrbhfnjfjbhnjbfhjhfkdjbfhjhjbhfeawfgnajwiohgobgouhovnbfrjfiebhjanbjfnnjfanruiqouhjnmfjighobnfnrmbnefnjmbaefnmnjafjbnfrbhfnjfjbhnjbfhjhfkdjbfhjhjbhfeawfgnajwiohgobgouhovnbfrjfiebhjanbjfnnjfanruiqouhjnmfjighobnfnrmbnefnjmbaefnmnjafjbnfrbhfnjfjbhnjbfhjhfkdjbfhjhjbh';
        const s = 'fbeufbeufbeu';
        const result = isSubsequence(t, s);

//        console.log(result);

        //  二刷
        function isSubsequence(s, t){
            if (t.length < s.length) {
                return false;
            }
            if (t === s) {
                return true;
            }
            let i = 0;
            let j = 0;
            let sLen = s.length;
            let tLen = t.length;
            while (i < sLen) {
                if (j === tLen) {
                    return false;
                }
                if (s.charAt(i) === t.charAt(j)) {
                    j++;
                    i++;
                } else {
                    j++;
                }
            }
            return true;
        }

        isSubsequence('abc', 'ahbgdc');
    })();
</script>
<br>
<p class="red">401. 二进制手表</p>
<p>⚠️难！</p>
<script data-msg="401. 二进制手表">
    (() => {
        var readBinaryWatch = function (num){
            const res = [];
            const hourstrs = [['0'], ['1', '2', '4', '8'], ['3', '5', '6', '9', '10'], ['7', '11']];
            const minstrs = [
                ['00'],
                ['01', '02', '04', '08', '16', '32'],
                ['03', '05', '06', '09', '10', '12', '17', '18', '20', '24', '33', '34', '36', '40', '48'],
                ['07', '11', '13', '14', '19', '21', '22', '25', '26', '28', '35', '37', '38', '41', '42', '44', '49', '50', '52', '56'],
                ['15', '23', '27', '29', '30', '39', '43', '45', '46', '51', '53', '54', '57', '58'],
                ['31', '47', '55', '59']
            ];
            for (let i = 0; i <= Math.min(3, num); i++) {
                if (num - i > 5) {
                    continue;
                }
                const hstr = hourstrs[i];
                const mstr = minstrs[num - i];
                for (let j = 0; j < hstr.length; j++) {
                    for (let k = 0; k < mstr.length; k++) {
                        res.push(hstr[j] + ':' + mstr[k]);
                    }
                }
            }
            return res;
        };
        const res = readBinaryWatch(8);

//        console.log(res);
        function readBinaryWatch(num){

        }
    })();
</script>
<br>
<p class="green">404. 左叶子之和</p>
<p>别和链表混了</p>
<script data-msg="404. 左叶子之和">
    (() => {
        function sumOfLeftLeaves(node){
            let sum = 0;

            function fn(node){
                if (node === null) {
                    return 0;
                }
                if (node.left && node.left.left === null && node.left.right === null) {
                    sum += node.left;
                }
                fn(node.left);
                fn(node.right);
            }

            fn(node);
            return sum;
        }

        //  二刷
        function sumOfLeftLeaves(node){
            if (node === null) {
                return 0;
            }
            let value = 0;
            let left = 0;
            if (node.left && node.left.left === null && node.left.right === null) {
                value = node.left.val;
            } else {
                left = sumOfLeftLeaves(node.left);
            }
            const right = sumOfLeftLeaves(node.right);
            return left + right + value;
        }
    })();
</script>
<br>
<p class="red">405. 数字转换为十六进制数</p>
<p>⚠️不管正负数，计算机总是用二进制存储表示这些数的，把它们看成无符号数，再统一转成16进制就好了</p>
<script data-msg="405. 数字转换为十六进制数">
    (() => {
        //  以前那是什么垃圾代码，要注意的点多
        //  二刷
        function toHex(n){
            n >>>= 32;
            const map = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f'];
            let str = '';
            while (n) {
                const d = n % 16;
                n = n >>> 4;
                str = map[d] + str;
            }
            return str || '0';
        }

        toHex(0);
    })();
</script>
<br>
<p>409. 最长回文串</p>
<p>💡最后判断一下ans是否比原字符串短，是就说明可以拿一个字符做中心，一样长就不行直接返回。</p>
<script data-msg="409. 最长回文串">
    (() => {

        function longestPalindrome(str){
            let sum = 0;
            for (let i = 0; i < str.length; i++) {
                const index = str.lastIndexOf(str[i]);
                //  奇数
                if (index === i) {
                    continue;
                }
                str = str.slice(0, i) + str.slice(i + 1, index) + str.slice(index + 1);
                sum += 2;
                i--;
            }
            if (str.length % 2 === 1) {
                sum++;
            }
            return sum;
        }

        const res = longestPalindrome('dccaccd');

        //  二刷
        function longestPalindrome(n){
            if (n === '') {
                return 0;
            }
            const obj = {};
            let count = 0;
            const len = n.length;
            for (let i = 0; i < len; i++) {
                const key = n.charAt(i);
                if (obj[key]) {
                    delete obj[key];
                    count += 2;
                } else {
                    obj[key] = true;
                }
            }
            if (len === count) {
                return count;
            }
            return count + 1;
        }

        longestPalindrome('a');

    })();
</script>
<br>
<p>412. Fizz Buzz”。</p>
<p>-</p>
<script data-msg="412. Fizz Buzz">
    (() => {

        function fizzBuzz(n){
            const arr = [];
            for (let i = 1; i <= n; i++) {
                if (i % 3 !== 0 && i % 5 !== 0) {
                    arr.push(i.toString());
                    continue;
                }
                let str = '';
                if (i % 3 === 0) {
                    str += 'Fizz';
                }
                if (i % 5 === 0) {
                    str += 'Buzz';
                }
                arr.push(str);
            }
            return arr;
        }

//        console.log(fizzBuzz(15));
//

        //  二刷
        function fizzBuzz(n){
            const list = [];
            for (let i = 1; i <= n; i++) {
                let str = '';
                if (i % 3 === 0) {
                    str = 'Fizz';
                }
                if (i % 5 === 0) {
                    str += 'Buzz';
                }
                list.push(str || i.toString());
            }
            return list;
        }
    })();
</script>
<br>
<p>414. 第三大的数</p>
<p>💡维护3个变量</p>
<script data-msg="414. 第三大的数">
    (() => {
        //  二刷
        function thirdMax(nums){
            let max = -Infinity;
            let second = -Infinity;
            let third = -Infinity;
            for (let value of nums) {
                if (value === max || value === second || value === third) {
                    continue;
                }
                if (value > max) {
                    third = second;
                    second = max;
                    max = value;
                } else if (value > second) {
                    third = second;
                    second = value;
                } else if (value > third) {
                    third = value;
                }
            }
            if (third === -Infinity) {
                return max;
            }
            return third;
        }
    })();
</script>
<br>
<p>415. 字符串相加</p>
<p>-</p>
<script data-msg="415. 字符串相加">
    (() => {
        const a = '23456768593847569893457968493407923456768593847569893457968493407921';
        const b = '485784039894597807938628094823456768593847569893457968493407948578';

        //  二刷
        function addStrings(num1, num2){
            let str = '';
            if (num1.length > num2.length) {
                const temp = num1;
                num1 = num2;
                num2 = temp;
            }
            let prev = 0;
            //  2 比 1 大
            for (let i = 0; i < num2.length; i++) {
                //  倒序
                //  如果num1为空字符串，设置为 '0'
                const str1 = num1[num1.length - 1 - i] || '0';
                const str2 = num2[num2.length - 1 - i];
                const value = +str1 + +str2 + prev;
                if (value > 9) {
                    prev = 1;
                } else {
                    prev = 0;
                }
                str = value % 10 + str;
            }
            if (prev) {
                str = '1' + str;
            }
            return str;
        }

        addStrings('1', '9');
    })();
</script>
<br>
<p>434. 字符串中的单词数</p>
<p>-</p>
<script data-msg="434. 字符串中的单词数">
    (() => {

        function countSegments(s){
            let max = 0;
            let current = 0;
            while (s.length) {
                if (s.substring(0, 1) === ' ') {
                    current = 0;
                } else {
                    current++;
                }
                max = Math.max(max, current);
                s = s.slice(1);
            }
            return max;
        }

        const res = countSegments('输入: "Hello, my name is John"');

        //  二刷
        function countSegments(s){
            let count = 0;
            let prevIsStr = false;
            for (let i = 0; i < s.length; i++) {
                if (s.charAt(i) === ' ') {
                    if (prevIsStr) {
                        count++;
                    }
                    prevIsStr = false;
                } else {
                    prevIsStr = true;
                }
            }
            if (prevIsStr) {
                count++;
            }
            return count;
        }
    })();
</script>
<br>
<p>441. 排列硬币</p>
<p>💡数学方法，二刷有进步</p>
<script data-msg="441. 排列硬币">
    (() => {
        function arrangeCoins(n){
            //  个数
            let i = 0;
            //  层数
            let c = 0;
            while (1) {
                c++;
                i += c;
                if (i > n) {
                    return c - 1;
                }
            }
        }

        const res = arrangeCoins(21);

        //  你总共有 n 枚硬币，三角形
        //  二刷
        function arrangeCoins(n){
            //  21 42 6.5 6
            const sqrt = Math.sqrt(n * 2)|0;
            //  n不够大
            if ((sqrt + 1) * sqrt / 2 > n) {
                return sqrt - 1;
            }
            return sqrt;
        }

    })();
</script>
<br>
<p class="red">443. 压缩字符串</p>
<p>⚠️双指针，未完成</p>
<script data-msg="443. 压缩字符串"></script>
<br>
<p class="red">447. 回旋镖的数量</p>
<p>⚠️数学，未完成</p>
<script data-msg="447. 回旋镖的数量">
    function numberOfBoomerangs(points){

    }
</script>
<br>
<p>448. 找到所有数组中消失的数字</p>
<p>💡和下标有关，因该是移动下表表示的数字，把下标与数字不对应的数字移动到正确的下标</p>
<script data-msg="448. 找到所有数组中消失的数字">
    (() => {
        //  二刷
        function findDisappearedNumbers(arr){
            arr.unshift(0);
            for (let i = 0; i < arr.length;) {
                const current = arr[i];
                //  相等
                if (current === i) {
                    i++;
                    continue;
                }
                //  不等的时候
                //  从后面的某个位置拉一个数过来
                if (arr[i] === arr[current]) {
                    arr[i] = false;
                    i++;
                } else {
                    arr[i] = arr[current];
                    //  目的是将这个数 移动到正确的标
                    arr[current] = current;
                }
            }
            const res = [];
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === false) {
                    res.push(i);
                }
            }
            return res;
        }

        //  [0, 1, 3, 3, 4, 5, 6, 7, 8];
    })();
</script>
<br>
<p class="orange">453. 最小移动次数使数组元素相等</p>
<p>💡n-1加分=1个扣分</p>
<script data-msg="453. 最小移动次数使数组元素相等">
    (() => {
        //  二刷
        function minMoves(arr){
            let min = Math.min.apply(null, arr);
            let count = 0;
            for (let value of arr) {
                count += (value - min);
            }
            return count;
        }

        minMoves([0, 10, 20]);
//
//        [1, 2, 3];
//        [2, 3, 3];
//        [3, 4, 3];
//        [4, 4, 4];
    })();
</script>
<br>
<p>455. 分发饼干</p>
<p>💡双指针</p>
<script data-msg="455. 分发饼干">
    (() => {
        function findContentChildren(children, pie){
            children = children.sort(sort);
            pie = pie.sort(sort);
            let i = 0;
            let j = 0;
            let s = 0;
            while (i < children.length && j < pie.length) {
                if (pie[j] >= children[i]) {
                    j++;
                    i++;
                    s++;
                } else {
                    i++;
                }
            }
            return s;
        }

        //  从大到小排序
        function sort(a, b){
            return b - a;
        }

//        const res = findContentChildren([1, 2], [1, 2, 3]);
//        console.log(res);

        //  二刷
        function findContentChildren(children, pie){
            children.sort((a, b) => a - b);
            pie.sort((a, b) => a - b);
            let c = 0;
            let p = 0;
            let count = 0;
            while (c < children.length && p < pie.length) {
                //  分配
                if (pie[p] >= children[c]) {
                    count++;
                    p++;
                    c++;
                    continue;
                }
                //  只能是换饼干，因为孩子的需求越来越大
                p++;
            }
            return count;
        }
    })();
</script>
<br>
<p class="orange">459. 重复的子字符串</p>
<p>⚠️数学，是一种思路，但是貌似不算太快</p>
<script data-msg="459. 重复的子字符串">
    (() => {
        function repeatedSubstringPattern(str){
            let i = 1;
            let len = str.length;
            while (i < Math.floor(len / 2) + 1) {
                //  如果除不尽
                if (len % 2 !== 0) {
                    i++;
                    continue;
                }
                let _str = ''.padEnd(len, str.slice(0, i));
                if (_str === str) {
                    return true;
                }
                i++;
            }
            return false;
        }

        const str = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';

        //  二刷
        function repeatedSubstringPattern(s){
            let times = 2;
            const len = s.length;
            while (times <= len) {
                if (len % times) {
                    times++;
                    continue;
                }
                const index = len / times;
                if (s.slice(0, index).repeat(times) === s) {
                    return true;
                }
                times++;
            }
            return false;
        }

        //  数学
        function repeatedSubstringPattern(s){
            const _s = (s + s).slice(1, -1);
            return _s.indexOf(s) !== -1;
        }
    })();
</script>
<br>
<p class="sky">461. 汉明距离</p>
<p>一看就是位运算</p>
<script data-msg="461. 汉明距离">
    (() => {
        function hammingDistance(a, b){
            let bin = a^b;
            let s = 0;
            while (bin) {
                if (bin % 2 === 1) {
                    s++;
                }
                bin = Math.floor(bin / 2);
            }
            return s;
        }

//        const res = hammingDistance(5, 4);
//        console.log(res);

        //  二刷
        function hammingDistance(a, b){
            let xor = a^b;
            let count = 0;
            while (xor) {
                //  得按位与一下1，如果末尾是1，才能算1次
                if (xor&1) {
                    count++;
                }
                xor >>>= 1;
            }
            return count;
        }
    })();
</script>
<br>
<p>463. 岛屿的周长</p>
<p>-</p>
<script data-msg="463. 岛屿的周长">
    (() => {
        function islandPerimeter(grid){
            let c = 0;
            //  层
            for (let i = 0; i < grid.length; i++) {
                //  列
                for (let j = 0; j < grid[i].length; j++) {
                    //  是陆地
                    if (grid[i][j] === 1) {
                        //  判断上下左右，如果是零，则+1
                        //  左右一定有
                        if (grid[i][j - 1] !== 1) {
                            c++;
                        }
                        if (grid[i][j + 1] !== 1) {
                            c++;
                        }
                        if (!grid[i - 1] || grid[i - 1][j] !== 1) {
                            c++;
                        }
                        if (!grid[i + 1] || grid[i + 1][j] !== 1) {
                            c++;
                        }
                    }
                }
            }
            return c;
        }

        const grid = [
            [0, 1, 0, 0],
            [1, 1, 1, 0],
            [0, 1, 0, 0],
            [1, 1, 0, 0]];
        const res = islandPerimeter(grid);

        //  二刷
        function islandPerimeter(grid){
            let count = 0;
            for (let i = 0; i < grid.length; i++) {
                const list = grid[i];
                for (let j = 0; j < list.length; j++) {
                    if (list[j] === 0) {
                        continue;
                    }
                    //  上
                    const upList = grid[i - 1];
                    if (upList === undefined || upList[j] === 0) {
                        count++;
                    }
                    //  下
                    const underList = grid[i + 1];
                    if (underList === undefined || underList[j] === 0) {
                        count++;
                    }
                    //  左
                    const left = list[j - 1];
                    if (left === undefined || left === 0) {
                        count++;
                    }
                    //  右
                    const right = list[j + 1];
                    if (right === undefined || right === 0) {
                        count++;
                    }
                }
            }
            return count;
        }
    })();
</script>
<br>
<p>475. 供暖器</p>
<p>数学？两两比较热水器，总保持第一个热水器离得更近，如果后面的更近，就++，如果没有更多的热水器了，就Infinity</p>
<script data-msg="475. 供暖器">
    (() => {
        return;
        //  暴力循环法，不好
        // function findRadius(houses, heaters){
        //     const range = [];
        //     let r = 1;
        //     while (1) {
        //         range.length = 0;
        //         for (let i = 0; i < heaters.length; i++) {
        //             range.push([heaters[i] - r, heaters[i] + r]);
        //         }
        //         let isInNum = 0;
        //         for (let i = 0; i < houses.length; i++) {
        //             for (let j = 0; j < range.length; j++) {
        //                 if (houses[i] >= range[j][0] && houses[i] <= range[j][1]) {
        //                     isInNum++;
        //                     break;
        //                 }
        //             }
        //         }
        //         if (isInNum === houses.length) {
        //             return r;
        //         }
        //         r++;
        //     }
        // }

        //  找到每个房子最近的那个，再获得其中最远的那个
        // function findRadius(houses, heaters){
        //     houses = houses.sort(sort);
        //     heaters = heaters.sort(sort);
        //     let max = 1;
        //     houses.forEach(item => {
        //         for (let i = 0; i < heaters.length; i++) {
        //             heaters[i + 1] = heaters[i + 1] || Infinity;
        //             if (Math.abs(item - heaters[i]) < Math.abs(item - heaters[i + 1])) {
        //                 max = Math.max(max, Math.abs(item - heaters[i]));
        //                 return;
        //             }
        //         }
        //     });
        //     return max;
        // }

        //  双指针法
        function findRadius(houses, heaters){
            let max = 1;
            let i = 0;
            let j = 0;
            houses = houses.sort(sort);
            heaters = heaters.sort(sort);
            while (i < houses.length && j < heaters.length) {
                heaters[j + 1] = heaters[j + 1] || Infinity;
                //  如果左侧没有暖气
                if (houses[i] <= heaters[j]) {
                    max = Math.max(max, Math.abs(houses[i] - heaters[j]));
                    i++;
                    continue;
                }
                //  如果左右都有暖气
                if (houses[i] > heaters[j]) {
                    max = Math.max(max, Math.min(Math.abs(houses[i] - heaters[j]), Math.abs(houses[i] - heaters[j + 1])));
                    i++;
                    //  如果左面的比右面的距离大
                    if (Math.abs(houses[i] - heaters[j]) >= Math.abs(houses[i] - heaters[j + 1])) {
                        j++;
                    }
                }
                //  右侧一定有暖气
            }
            return max;
        }

        function sort(a, b){
            return a - b;
        }

        const houses = [-5, 2, 10, 14];
        const heaters = [1, 11];
        const res = findRadius(houses, heaters);
        console.log(res);
    })();
    //  二刷
    (() => {
        function findRadius(houses, hot){
            houses.sort((a, b) => a - b);
            hot.sort((a, b) => a - b);
            //  最小半径
            let radius = 0;
            //  热水器的index
            let hotIndex = 0;
            for (let i = 0; i < houses.length; i++) {
                const radius1 = Math.abs(houses[i] - hot[hotIndex]);
                let radius2;
                //  没有更多的热水器了
                if (hot[hotIndex + 1] === undefined) {
                    //  就当作离得非常远就行了
                    radius2 = Infinity;
                } else {
                    radius2 = Math.abs(houses[i] - hot[hotIndex + 1]);
                }
                //  正常情况
                if (radius2 > radius1) {
                    radius = Math.max(radius1, radius);
                } else {
                    //  后面的热水器离得更近
                    //  用后面的热水器
                    hotIndex++;
                    //  重新判断一次
                    i--;
                }
            }
            return radius;
        }

        findRadius([282475249, 622650073, 984943658, 144108930, 470211272, 101027544, 457850878, 458777923], [823564440, 115438165, 784484492, 74243042, 114807987, 137522503, 441282327, 16531729, 823378840, 143542612]);

        //  [282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923]
        //  [823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612]
    })();
</script>
<br>
<p class="sky">476. 数字的补数</p>
<p>一看就是位运算</p>
<script data-msg="476. 数字的补数">
    (() => {
        //  二刷
        function findComplement(nums){
            nums >>>= 32;
            let times = 0;
            const _nums = nums;
            while (nums) {
                nums >>= 1;
                times <<= 1;
                times++;
            }

            return _nums^times;
        }

        findComplement(2);

    })();
</script>
<br>
<p>482. 密钥格式化</p>
<p>-</p>
<script data-msg="482. 密钥格式化">
    (() => {
//        return;

        function licenseKeyFormatting(S, K){
            let str = S.toUpperCase().split('-').join('');
            let res = '';
            while (str.length > K) {
                const current = str.substr(-K);
                res = `${current}-${res}`;
                str = str.slice(0, str.length - K);
            }
            res = `${str}-${res}`;
            if (res[res.length - 1] === '-') {
                res = res.slice(0, res.length - 1);
            }
            return res;
        }

        // const res = licenseKeyFormatting('5F3Z-2e-9-w', 4);
//        const res = licenseKeyFormatting('2-5g-3-J', 2);
//        console.log(res);

        //  二刷
        function licenseKeyFormatting(S, K){
            const list = S.split('').reverse();
            let count = 0;
            for (let i = 0; i < list.length; i++) {
                //  如果是-
                if (list[i] === '-') {
                    list.splice(i, 1);
                    i--;
                    continue;
                }
                if (count === K) {
                    list.splice(i, 0, '-');
                    count = 0;
                    i++;
                }
                list[i] = list[i].toUpperCase();
                count++;
            }
            list.reverse();
            return list.join('');
        }

        function licenseKeyFormatting(S, K){
            S = S.replace(/\-/ig, '').toUpperCase();
            let str = '';
            let count = 0;
            for (let i = S.length - 1; i >= 0; i--) {
                str = S[i] + str;
                count++;
                if (count === K) {
                    str = '-' + str;
                    count = 0;
                }
            }
            if (str[0] === '-') {
                str = str.slice(1);
            }
            return str;
        }

        licenseKeyFormatting('5F3Z-2e-9-w', 4);
    })();
</script>
<br>
<p>485. 最大连续1的个数</p>
<p>-</p>
<script data-msg="485. 最大连续1的个数">
    (() => {
        function findMaxConsecutiveOnes(nums){
            let max = 0;
            let sum = 0;
            nums.reduce((prev, current) => {
                if (prev === 0) {
                    sum = 0;
                }
                if (current === 1) {
                    sum++;
                    max = Math.max(max, sum);
                }
                return current;
            }, 0);
            return max;
        }

        const res = findMaxConsecutiveOnes([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);

        //  二刷
        function findMaxConsecutiveOnes(nums){
            let max = 0;
            let pre = 0;
            for (let value of nums) {
                if (value) {
                    pre++;
                    max = Math.max(pre, max);
                } else {
                    pre = 0;
                }
            }
            return max;
        }

    })();
</script>
<br>
<p>492. 构造矩形</p>
<p>仔细读题，双指针法</p>
<script data-msg="492. 构造矩形">
    (() => {
        //  给定的面积不大于 10,000,000 且为正整数。
        // 你设计的页面的长度和宽度必须都是正整数
        function constructRectangle(area){
            const sqrt = Math.sqrt(area);
            //  是正方形
            if (sqrt % 1 === 0) {
                return [sqrt, sqrt];
            }
            let w = Math.floor(sqrt);
            let l = 0;
            while (w > 1) {
                l = area / w;
                if (l % 1 === 0) {
                    return [w, l];
                }
                w--;
            }
            return [1, area];
        }

//        const res = constructRectangle(1602);
//        console.log(res);

        //  二刷
        function constructRectangle(area){
            const sqrt = Math.sqrt(area);
            const list = [];
            //  正方形
            if ((sqrt|0) === sqrt) {
                list[1] = list[0] = sqrt;
            } else {
                //  长方形
                //  二分法
                let w = (sqrt|0);
                let l = w + 1;
                while (1) {
                    const _area = w * l;
                    if (area > _area) {
                        l++;
                    } else if (area < _area) {
                        w--;
                    } else {
                        list[0] = l;
                        list[1] = w;
                        break;
                    }
                }
            }
            return list;
        }

    })();
</script>
<br>
<p class="orange">496. 下一个更大元素 I</p>
<p>⚠️值得研究，维护单调栈，维护map，没重复肯定map。</p>
<script data-msg="496. 下一个更大元素 I">
    (() => {
        // return;
        //  暴力法
        // function nextGreaterElement(nums1, nums2){
        //     const res = new Array(nums1.length);
        //     nums1.forEach((item, i) => {
        //         const index = nums2.indexOf(item);
        //         const greatThan = nums2.slice(index).find(_item => {
        //             return _item > item;
        //         });
        //         if (!greatThan) {
        //             res[i] = -1;
        //             return;
        //         }
        //         res[i] = greatThan;
        //     });
        //     return res;
        // }

        //  hash 法
        function nextGreaterElement(nums1, nums2){
            console.log(nums1);
            console.log(nums2);
            const hash = {};
            nums2.forEach((item, index) => {
                hash[item] = -1;
                //  剩余的数组
                const reArr = nums2.slice(index + 1);
                //  之后第一个大的index
                let _index = reArr.find(_item => {
                    return _item > item;
                });
                //  如果没有
                if (_index === undefined) {
                    return;
                }
                hash[item] = _index;
            });
            console.log(hash);
            const arr = new Array(nums1.length);
            // debugger
            nums1.forEach((item, index) => {
                arr[index] = hash[item];
            });
            return arr;
        }

        const nums1 = [4, 1, 2];
        const nums2 = [1, 3, 4, 2];
        //
        // const nums1 = [2, 4];
        // const nums2 = [1, 2, 3, 4];

//        const res = nextGreaterElement(nums1, nums2);

        //  二刷
        function nextGreaterElement(nums1, nums2){
            const map = {};
            const stack = [];
            for (let i = 0; i < nums2.length - 1; i++) {
                const current = nums2[i];
                const next = nums2[i + 1];
                //  如果右面的更大，说明就是右面的第一个更大的数
                if (next > current) {
                    map[current] = next;
                    while (stack[0] < next) {
                        map[stack[0]] = next;
                        stack.shift();
                    }
                } else {
                    stack.unshift(current);
                }
            }
            return nums1.map(item => map[item] || -1);
        }
    })();
</script>
<br>
<p>500. 键盘行</p>
<p>-</p>
<script data-msg="500. 键盘行">
    (() => {
        const map = {
            'q': 1,
            'w': 1,
            'e': 1,
            'r': 1,
            't': 1,
            'y': 1,
            'u': 1,
            'i': 1,
            'o': 1,
            'p': 1,
            'Q': 1,
            'W': 1,
            'E': 1,
            'R': 1,
            'T': 1,
            'Y': 1,
            'U': 1,
            'I': 1,
            'O': 1,
            'P': 1,
            'a': 2,
            's': 2,
            'd': 2,
            'f': 2,
            'g': 2,
            'h': 2,
            'j': 2,
            'k': 2,
            'l': 2,
            'A': 2,
            'S': 2,
            'D': 2,
            'F': 2,
            'G': 2,
            'H': 2,
            'J': 2,
            'K': 2,
            'L': 2,
            'z': 3,
            'x': 3,
            'c': 3,
            'v': 3,
            'b': 3,
            'n': 3,
            'm': 3,
            'Z': 3,
            'X': 3,
            'C': 3,
            'V': 3,
            'B': 3,
            'N': 3,
            'M': 3
        };

        function findWords(words){
            const list = [];
            wrap:for (const str of words) {
                let prev = map[str[0]];
                for (let i = 1; i < str.length; i++) {
                    if (map[str[i]] !== prev) {
                        continue wrap;
                    }
                }
                list.push(str);
            }
            return list;
        }
    })();
</script>
<br>
<p class="red">501. 二叉搜索树中的众数</p>
<p>🌲⚠️️⚠️️⚠️️</p>
<script data-msg=">501. 二叉搜索树中的众数">
    (() => {
        //  中序遍历，然后就是一个有序数组了，不需要额外的空间，中序遍历难，那就快排递归
        function findMode(root){
            console.log(root);
            root = quickSort(root);
            console.log(root);
            let max = 0;
            let item = null;
            let sum = 0;

            for (let i = 0; i < root.length; i++) {
                if (root[i] === item) {
                    sum++;
                    if (sum >= max) {
                        max = sum;
                    }
                    continue;
                }
                item = root[i];
                sum = 1;
            }
            return max;
        }

        function quickSort(arr){
            if (arr.length <= 1) {
                return arr;
            }
            let left = [];
            let right = [];
            let middleArr = [];
            let middle = Math.floor(arr.length / 2);
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] < arr[middle]) {
                    left.push(arr[i]);
                } else if (arr[i] > arr[middle]) {
                    right.push(arr[i]);
                } else {
                    middleArr.push(arr[i]);
                }
            }
            return quickSort(left).concat(middleArr).concat(quickSort(right));
        }

//        const res = findMode([1, null, 2, 2]);

        //  二刷
        function findMode(){

        }
    })();
</script>
<br>
<p>504. 七进制数</p>
<p>⚠️要考虑的东西还是蛮多的，负数，零</p>
<script data-msg="504. 七进制数">
    (() => {
        function convertToBase7(num){
            const arr = [];
            while (num > 0) {
                const res = num % 7;
                arr.unshift(res);
                num = Math.floor(num / 7);
            }
            return arr.join('');
        }

//        const res = convertToBase7(100);
//        console.log(res);

        //  二刷
        function convertToBase7(nums){
            let str = '';
            if (nums === 0) {
                return '0';
            }
            const isLessThanZero = nums < 0;
            if (isLessThanZero) {
                nums = -nums;
            }
            while (nums) {
                str = nums % 7 + str;
                nums = (nums / 7)|0;
            }
            if (isLessThanZero) {
                str = '-' + str;
            }
            return str;
        }

        convertToBase7(-8);
    })();
</script>
<br>
<p>506. 相对名次</p>
<p>有一种额外方法，空间换取时间</p>
<script data-msg="506. 相对名次">
    (() => {
        function findRelativeRanks(list){
            const price = ['Gold Medal', 'Silver Medal', 'Bronze Medal'];
            let len = price.length;
            while (len) {
                const min = Math.min.apply(null, list);
                const index = list.indexOf(min);
                list.splice(index, 1);
                len--;
            }
            return price.concat(list);
        }

        //  二刷
        function findRelativeRanks(list){
            const price = ['Gold Medal', 'Silver Medal', 'Bronze Medal'];
            //  源数据
            const origin = list.map(item => item);
            list.sort((a, b) => b - a);
            //  前三，真删了
            const top3 = list.splice(0, 3);
            const topMap = {};
            top3.forEach((item, index) => {
                topMap[item] = price[index];
            });
            const map = {};
            //  后面的名次了
            list.forEach((item, index) => {
                //  前面删了3个
                map[item] = (index + 4).toString();
            });
            return origin.map(item => {
                return topMap[item] || map[item];
            });

        }

        //  一种特殊方法
        function findRelativeRanks(list){
            const max = Math.max.apply(null, list);
            //  mapList记录的是，当前这个分数下，list的下标
            const mapList = new Array(max + 1).fill(-Infinity);
            for (let i = 0; i < list.length; i++) {
                mapList[list[i]] = i;
            }

            const price = ['Gold Medal', 'Silver Medal', 'Bronze Medal'];
            //  [5, 2, 3] ->  [,,1,2,,0]
            let next = 4;
            for (let i = mapList.length - 1; i >= 0; i--) {
                const item = mapList[i];
                if (item === -Infinity) {
                    continue;
                }
                list[item] = price.length ? price.shift() : (next++).toString();
            }
            return list;
        }

    })();
</script>
<br>
<p>507. 完美数</p>
<p>⚠️这是第一次二刷不如初始的</p>
<script data-msg="507. 完美数">
    (() => {
        function checkPerfectNumber(num){
            const sqrt = Math.sqrt(num);
            let i = 1;
            let sum = 0;
            while (i <= sqrt) {
                if (num % i === 0) {
                    console.log(i, num / i);
                    sum += i;
                    sum += num / i;
                }
                i++;
            }
            if (sqrt % 1 === 0) {
                sum -= sqrt;
            }
            sum /= 2;
            console.log(sum);
            return sum === num;
        }

//        const res = checkPerfectNumber(18);
//        console.log(res);

        //  二刷
        function checkPerfectNumber(num){
            const list = [1];
            let left = Math.sqrt(num)|0;
            if (left * left === num) {
                list.push(left);
                left--;
            }
            let right = left + 1;
            while (left > 1) {
                const res = left * right;
                if (res === num) {
                    list.push(left);
                    list.push(right);
                    left--;
                    right++;
                } else {
                    left--;
                    right = (num / left)|0;
                }
            }
            return list.reduce((prev, current) => prev + current, 0) === num;
        }

        //  again
        function checkPerfectNumber(num){
            if (num === 0) {
                return false;
            }
            let sqrt = Math.sqrt(num);

            //  while循环多加了一个num，在sqrt===1的时候
            let sum = -num;
            if ((sqrt|0) === sqrt) {
                sum += sqrt;
                sqrt--;
            } else {
                sqrt = sqrt|0;
            }
            while (sqrt) {
                if (num % sqrt === 0) {
                    sum += sqrt;
                    sum += num / sqrt;
                }
                sqrt--;
            }
            return num === sum;
        }

        checkPerfectNumber(0);
    })();
</script>
<br>
<p>509. 斐波那契数</p>
<p>经典</p>
<script data-msg="509. 斐波那契数">
    (() => {
        return;
        // function fib(n){
        //     if (n <= 2) {
        //         return 1;
        //     }
        //     return fib(n - 1) + fib(n - 2);
        // }

        // function fib(n){
        //     let a = 0;
        //     let b = 1;
        //     let c;
        //     while (n) {
        //         c = a;
        //         a = b;
        //         b = c + b;
        //         n--;
        //     }
        //     return a;
        // }

        function fib(n, a, b){
            a = a || 0;
            b = b || 1;
            if (n <= 2) {
                return a + b;
            }
            return fib(--n, b, a + b);
        }

        function fib(n){
            if (n <= 1) {
                return n;
            }
            return fn(n - 1);
        }

        function fn(n, a, b){
            n = n || 0;
            a = a || 0;
            b = b || 1;
            if (n === 0) {
                return b;
            }
            return fn(n - 1, b, a + b);
        }

        for (let i = 0; i < 10; i++) {
            const res = fib(i);
            console.log(res);
        }

    })();
</script>
<br>
<p>520. 检测大写字母</p>
<p>-</p>
<script data-msg="520. 检测大写字母">
    (() => {
        //  二刷
        function detectCapitalUse(word){
            if (word.toUpperCase() === word) {
                return true;
            }
            if (word.toLowerCase() === word) {
                return true;
            }
            const startUnicode = word.charCodeAt(0);
            //  首字母必须大写了
            if (!(startUnicode >= 64 && startUnicode <= 89)) {
                return false;
            }
            for (let i = 1; i < word.length; i++) {
                const startUnicode = word.charCodeAt(i);
                //  必须是小写字母
                if (!(startUnicode >= 97 && startUnicode <= 122)) {
                    return false;
                }
            }
            return true;
        }

        detectCapitalUse('Leetceo');
    })();
</script>
<br>
<p>521. 最长特殊序列 Ⅰ</p>
<p>垃圾题目</p>
<script data-msg="521. 最长特殊序列 Ⅰ">
    (() => {
        function findLUSlength(a, b){
            if (a === b) {
                return -1;
            }
            if (a.length === b.length) {
                return a.length;
            }
            return Math.max(a.length, b.length);

        }
    })();
</script>
<br>
<p class="green">530. 二叉搜索树的最小绝对差</p>
<p>⚠️二叉搜索树，不是后续遍历，应该中序遍历</p>
<p>⚠️中序遍历</p>
<script data-msg="530. 二叉搜索树的最小绝对差">
    (() => {
        function getMinimumDifference(list){
            list = list.sort((a, b) => a - b);
            let min = Infinity;
            list.reduce((prev, current) => {
                let diff = current - prev;
                if (diff < min) {
                    min = Infinity;
                }
                return current;
            });
            return min;
        }

        //  二刷
        function getMinimumDifference(root){
            if (root === null) {
                return 0;
            }
            const list = [];
            traverse(root, list);
            let minDiff = Infinity;
            for (let i = 1; i < list.length; i++) {
                const prev = list[i - 1];
                const current = list[i];
                if (current - prev < minDiff) {
                    minDiff = current - prev;
                }
            }
            return minDiff;
        }

        //  push
        function traverse(node, list){
            if (node.left) {
                traverse(node.left, list);
            }
            list.push(node.val);
            if (node.right) {
                traverse(node.right, list);
            }
            return list;
        }

        //  中序遍历
        function getMinimumDifference(root){
            if (root === null) {
                return 0;
            }
            //  前一个
            let prev = null;
            let min = Infinity;

            function traverse(root){
                if (root.left) {
                    traverse(root.left);
                }
                if (prev && prev !== root) {
                    const dif = prev.val - root.val;
                    min = Math.min(min, Math.abs(dif));
                }
                prev = root;
                if (root.right) {
                    traverse(root.right);
                }
                return min;
            }

            return traverse(root);
        }

        //         236
        //     104      701
        //  null 227  null 911

        //         600
        //    424       612
        //  null 499  null 689
    })();
</script>
<br>
<p class="red">532. 数组中的K-diff数对</p>
<p>⚠️非常有价值，用一个map去重的思想。</p>
<script data-msg="532. 数组中的K-diff数对">
    (() => {
        //  二刷
        function findPairs(nums, k){
            if (k < 0) {
                return 0;
            }
            const obj = {};
            const diff = new Set();
            console.log(nums);
            //  💡💡💡💡️原理是总是存一个小的
            for (const value of nums) {
                if (obj[value - k]) {
                    //  对于 1 - 3 对，这个 存的是 1
                    diff.add(value - k);
                }
                if (obj[value + k]) {
                    //  对于3 - 5 对，这个存的是 3
                    diff.add(value);
                }
                obj[value] = true;
                console.log('🍎obj', obj, '🍎value', value, '🍎k', k, '🍎diff', diff);
            }
            console.log(diff.size);
            return diff.size;
        }

//        function findPairs(nums, k){
//            if (k < 0) {
//                return 0;
//            }
//            //  除重用
//            const asSet = {};
//            //  计数
//            let count = 0;
//            if (k === 0) {
//                for (const value of nums) {
//                    if (asSet[value] === false) {
//                        asSet[value] = true;
//                        count++;
//                        continue;
//                    }
//                    if (!asSet[value]) {
//                        asSet[value] = false;
//                    }
//                }
//            } else {
//                for (const value of nums) {
//                    if (asSet[value]) {
//                        continue;
//                    }
//                    asSet[value] = true;
//                    if (asSet[value - k]) {
//                        count++;
//                    }
//                    if (asSet[value + k]) {
//                        count++;
//                    }
//                }
//            }
//            return count;
//        }

//        debugger
//        findPairs([6, 3, 5, 7, 2, 3, 3, 8, 2, 4], 2);
//        findPairs([1, 3, 1, 5, 4], 0);
//        findPairs([1, 1, 1, 1, 1], 0);
        //  findPairs([1, 2, 3, 4, 5], 1);
        findPairs([1, 5, 3], 2);
        //  输入: [3, 1, 4, 1, 5], 2
    })();
</script>
<p class="red">538. 把二叉搜索树转换为累加树，给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<script data-msg="538. 把二叉搜索树转换为累加树">
    (() => {

    })();
</script>
<p>541. 反转字符串 II，给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k
    个，则反转前 k 个字符，其余字符保持原样。</p>
<script data-msg="541. 反转字符串 II">
    (() => {
        return;

        function reverseStr(s, k){
            let str = '';
            for (let i = 0; i < s.length; i += k) {
                let _s = s.slice(i, i + k);
                if (i % (k * 2) === 0) {
                    _s = _s.split('').reverse().join('');
                }
                str += _s;
            }
            return str;
        }

        const str = reverseStr('abcdefg', 2);
        console.log(str);

    })();
</script>
<p class="red">543. 二叉树的直径，给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<script data-msg="543. 二叉树的直径">
    (() => {
        function diameterOfBinaryTree(root){
            function getNode(node){
                if (!node.value) {
                    return;
                }
                if (!node.left && !node.right) {
                    sum++;
                    return;
                }
                if (node.left || node.right) {
                    getNode(node.left);
                    getNode(node.right);
                }

            }

            let sum = 0;

            getNode(root);
        }
    })();
</script>
<p>551. 学生出勤记录 I</p>
<script data-msg="551. 学生出勤记录 I">
    (() => {
        return;

        function checkRecord(str){
            let l = true;
            let a = true;
            const arr = str.split('');
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === 'A') {
                    a = false;
                }
                if (arr[i - 2] === 'L' && arr[i - 1] === 'L' && arr[i] === 'L') {
                    l = false;
                }
                if (!a && !l) {
                    return false;
                }
            }
            return true;
        }

        console.log(checkRecord('PPALLP'));
        console.log(checkRecord('PPALLL'));
    })();
</script>
<p>557. 反转字符串中的单词 III，给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<script data-msg="557. 反转字符串中的单词 III">
    (() => {
        return;

        function reverseWords(str){
            const arr = str.split(' ');
            const res = [];
            for (let i = 0; i < arr.length; i++) {
                res.push(arr[i].split('').reverse().join(''));
            }
            return res.join(' ');
        }

        console.log(reverseWords('Let\'s take LeetCode contest'));
        console.log(reverseWords('s\'teL ekat edoCteeL tsetnoc'));
    })();
</script>
<p>559. N叉树的最大深度，给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<script data-msg="N叉树的最大深度">
    (() => {
        return;

        function maxDepth(root){
            let max = 0;

            function setDepth(root, n){
                root.depth = n;
                max = Math.max(max, root.depth);
                if (root.children) {
                    root.children.forEach(item => {
                        setDepth(item, root.depth + 1);
                    });
                }

            }

            setDepth(root, 1);
            return max;
        }
    })();
</script>
<p>561. 数组拆分 I，给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<script data-msg="561. 数组拆分 I">
    (() => {
        function arrayPairSum(list){
            if (list % 2) {
                throw new Error('错误的数据');
            }
            list = list.sort((a, b) => a - b);
            const map = {};
            for (let i = 0; i < list.length; i += 2) {
                map[i] = [list[i], list[i + 1]];
            }
            return map;
        }

    })();
</script>
<p>563. 二叉树的坡度，给定一个二叉树，计算整个树的坡度。 一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。 整个树的坡度就是其所有节点的坡度之和。</p>
<script data-msg="563. 二叉树的坡度">
    (() => {

        function findTilt(root){
            let leftSum = 0;
            let rightSum = 0;

            function fn(node){
                if (!node.value) {
                    return;
                }
                if (node.left) {
                    leftSum += fn(node.left);
                }
                if (node.right) {
                    rightSum += fn(node.right);
                }
                return node.value;
            }

            fn(root);

            return Math.abs(leftSum - rightSum);
        }

    })();
</script>
<p>566.重塑矩阵</p>
<script data-msg="566.重塑矩阵">
    (() => {
        return;

        function matrixReshape(nums, r, c){
            let len = nums.length * nums[0].length;
            //  原数组
            if (r * c !== len) {
                return nums;
            }
            const arr = [];
            for (let item of nums) {
                arr.push(...item);
            }
            const res = [];
            for (let i = 0; i < r; i++) {
                res.push(arr.splice(0, c));
            }
            return res;
        }

        const res = matrixReshape([[1, 2], [3, 4]], 2, 2);
        // const res = matrixReshape([[1, 2, 3, 4]], 2, 2);
        console.log(res);
    })();
</script>
<p class="red">572. 另一个树的子树，给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<script data-msg="572. 另一个树的子树">
    (() => {
        function isSubtree(s, t){
            // if( )
        }

    })();
</script>
<p>575. 分糖果，给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<script data-msg="575. 分糖果">
    (() => {
        return;

        function distributeCandies(candies){
            return Math.min([...new Set(candies)].length, candies.length / 2);
        }

        const res = distributeCandies([1, 1, 2, 2, 3, 3]);
        console.log(res);
    })();
</script>
<p class="orange">581. 最短无序连续子数组，给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。</p>
<script data-msg="581. 最短无序连续子数组">
    (() => {
        return;

        //  ⚠️思路：假设中间有一个子数组，把它往两边扩张，那么需要从左到右推右边，从右到左推左边
        function findUnsortedSubarray(list){
            let min = Infinity;
            let left = null;
            for (let i = list.length - 1; i >= 0; i--) {
                min = Math.min(min, list[i]);
                if (min >= list[i]) {
                    continue;
                }
                left = i;
            }
            let max = -Infinity;
            let right = null;
            for (let i = 0; i < list.length; i++) {
                max = Math.max(list[i], max);
                if (max <= list[i]) {
                    continue;
                }
                right = i;
            }
            if (left === null || right === null) {
                return 0;
            }
            console.log(left, right);
            return right - left + 1;
        }

        const res = findUnsortedSubarray([2, 4, 6, 7, 5, 1, 4, 8, 10, 9, 15]);
        // const res = findUnsortedSubarray([1, 2, 3, 4]);
        // const res = findUnsortedSubarray([2, 1]);
        console.log(res);

    })();
</script>
<p class="red">589. N叉树的前序遍历，给定一个 N 叉树，返回其节点值的前序遍历。</p>
<script data-msg="589. N叉树的前序遍历">
    (() => {
        // function preorder(root){
        //     const arr = [];
        //
        //     function preorderFn(node){
        //         if (!node.value) {
        //             return;
        //         }
        //         const left = preorderFn(node.left);
        //         if (left) {
        //             arr.push(left);
        //         }
        //         const right = preorderFn(node.right);
        //         if (left) {
        //             arr.push(right);
        //         }
        //         arr.push(node.value);
        //         return node.value;
        //     }
        //
        //     preorderFn(root);
        //     return arr;
        // }

        var preorder2 = function (root){
            if (!root) return [];

            var res = [], arr = [root];
            while (arr.length) {
                var current = arr.pop();
                res.push(current.val);

                for (var i = current.children.length - 1; i >= 0; i--) {
                    arr.push(current.children[i]);
                }
            }
            return res;
        };

    })();
</script>
<p class="red">590. N叉树的后序遍历</p>
<script data-msg="590. N叉树的后序遍历"></script>
<p class="orange">594. 最长和谐子序列，和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。 现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<script data-msg="594. 最长和谐子序列">
    (() => {
        return;
        //  这是另一个题目了
        // function findLHS(nums){
        //     //  前一个数的结果
        //     let preRes = 0;
        //     let start = 0;
        //     //  最大的子串长度
        //     let maxLength = 0;
        //     // debugger;
        //     //  从左到右
        //     for (let i = 0; i < nums.length; i++) {
        //         //  如果绝对值的差大于1
        //         if (Math.abs(nums[i] - nums[i - 1]) > 1 || isNaN(nums[i - 1])) {
        //             maxLength = Math.max(1, maxLength);
        //             preRes = 0;
        //             start = i;
        //             continue;
        //         }
        //         const _preRes = preRes;
        //         preRes = nums[i] - nums[i - 1];
        //         //  如果连续的递增或递减
        //         if (nums[i] - nums[i - 1] === _preRes) {
        //             start = i;
        //             continue;
        //         }
        //         //  如果是波动的
        //         maxLength = Math.max(i - start, maxLength);
        //     }
        //     return maxLength;
        // }

        //  遍历两遍
        // function findLHS(list){
        //     const hash = {};
        //     let max = 0;
        //     for (let i = 0; i < list.length; i++) {
        //         hash[list[i]] = hash[list[i]] || 0;
        //         hash[list[i]]++;
        //     }
        //     for (let key in hash) {
        //         if (!hash.hasOwnProperty(key)) {
        //             continue;
        //         }
        //         if (hash[Number(key) + 1] !== undefined) {
        //             max = Math.max(hash[key] + hash[Number(key) + 1], max);
        //         }
        //     }
        //     return max;
        // }

        //  🌟好算法
        function findLHS(list){
            const hash = {};
            let max = 0;
            for (let i = 0; i < list.length; i++) {
                const key = list[i];
                const preKey = +key - 1;
                const nextKey = +key + 1;
                hash[key] = hash[key] || 0;
                hash[key]++;
                if (hash[preKey] !== undefined) {
                    max = Math.max(hash[key] + hash[preKey], max);
                }
                if (hash[nextKey] !== undefined) {
                    max = Math.max(hash[key] + hash[nextKey], max);
                }
            }
            return max;
        }

        // const res = findLHS([1, 3, 2, 2, 5, 2, 3, 7]);
        // const res = findLHS([1, 3, 5, 7, 9, 11, 13, 15, 17]);
        // const res = findLHS([1, 1, 1, 1]);
        // const res = findLHS([1, 2, 2, 1]);
        // const res = findLHS([3751, 8640, -5020, 1851, 4196, 2738, 3730, 1258, -8906, 8825, 3392, 9015, 8184, 6439, 7219, -95, 3511, 3573, -1304, 4200, 2009, -934, 4001, 9269, 8599, 3440, 8419, 1101, 8700, 1228, 6962, 5431, 9593, 5449, -3994, 1873, 5198, 6912, -7428, 9610, 9824, 6694, 1417, -5633, -5526, 5608, 5141, 816, 7380, 9444, 4948, 9252, -386, 3144, 7701, 4867, 6059, 5210, 9669, 4139, -3215, 493, 2527, 8031, 6828, 9554, 8515, 2065, -1157, 3547, 3317, 5042, 1454, -2964, 9130, 6430, 9539, 4500, 8539, 4814, 9363, 2215, 9256, 7021, 4934, 9772, 1241, 7628, 2035, 189, 5082, 5010, 8862]);
        const res = findLHS([1, 2, 2, 3, 4, 5, 1, 1, 1, 1]);

        console.log(res);
    })();
</script>
<p>598. 范围求和 II，给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 <= i < a
    以及 0 <= j < b 的元素 M[i][j] 的值都增加 1。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>
<script data-msg="598. 范围求和 II">
    (() => {
        return;

        function maxCount(m, n, ops){
            if (ops.length === 0) {
                return m * n;
            }
            let cols = Infinity;
            let row = Infinity;
            for (let i = 0; i < ops.length; i++) {
                cols = Math.min(ops[i][0], cols);
                row = Math.min(ops[i][1], row);
            }
            return cols * row;
        }

        const res = maxCount(3, 3, [[2, 2], [3, 3]]);
        console.log(res);
    })();
</script>
</body>
</html>





















