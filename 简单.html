<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>题库</title>
    <style>
        .red {
            color: red;
        }
    </style>
</head>
<body>
<p class="red">121.买股票的最佳时机</p>
<script data-msg="121.买股票的最佳时机">
    (() => {
        function getValue(arr){
            //  如果一共就一天，没得买
            if (arr.length < 2) {
                return 0;
            }
            //  历史最低的index，需要一直变动，更新，将来的大值要减去这个值
            let _minIndex = 0;
            //  最大差值，如果将来某个值减去历史最大值比这个值还大，需要更新
            let _diff = 0;
            for (let i = 1; i < arr.length; i++) {
                //  如果是历史最低值
                if (arr[i] - arr[_minIndex] < 0) {
                    _minIndex = i;
                    //  肯定没戏了
                    continue;
                }
                //  如果比差值大，记录这个值-最低值
                if (arr[i] - arr[_minIndex] > _diff) {
                    _diff = arr[i] - arr[_minIndex];
                }
            }
            return { _minIndex, _diff };
        }

        const arr = [2, 0, 2, -33, 33, 3, 9, 43, -214, -222];
        // console.log(getValue(arr));
    })();
</script>
<p>122.买股票2</p>
<script data-msg="122.买股票2">
    (() => {
        const arr = [2, 32, 60, -1, 43, 43, 32, -333, 3];

        function getValue(arr){
            if (arr.length < 1) {
                return 0;
            }
            //  总价
            let total = 0;
            for (let i = 1; i < arr.length; i++) {
                let diff = arr[i] - arr[i - 1];
                //  如果跌了
                if (diff < 0) {
                    //  等下一次
                    continue;
                }
                total += diff;
            }
            return {
                total,
            };
        }

        // console.log(getValue(arr));
    })();
</script>
<p>125.验证回文串</p>
<script data-msg="125.验证回文串">
    (() => {
        let str = '1112345432111';

        function getValue(str){
            let len = str.length;
            for (let i = 0; i < len / 2; i++) {
                if (str[i] !== str[(len - 1) - i]) {
                    return false;
                }
            }
            return true;
        }

        // console.log(getValue(str));
    })();
</script>
<p class="red">136.只有一次的数字</p>
<script data-msg="136.只有一次的数字">
    (function (){
        //  异或计算，一趟搞定。时间复杂度o(n)，答案为３，因为两个相同的数异或为０．
        const arr = [23, 4, 23, 43, 23, 44, 2, 4, 43, 23, 44, 2, 37];
        let value = 0;
        for (let i = 0; i < arr.length; i++) {
            value ^= arr[i];
            // console.log(value);
        }
        // console.log(value);

        //  拓展
        const a = [2, 3, 4, 5, 6, 7, 8, 9, 21, 33, 66];
        const _a = [2, 3, 4, 5, 6, 7, 7, 8, 9, 21, 33, 66];
        let _value = 0;
        let _value_ = 0;
        for (let i = 0; i < a.length; i++) {
            _value ^= a[i];
        }
        for (let i = 0; i < _a.length; i++) {
            _value_ ^= _a[i];
        }
        // console.log(_value ^ _value_);

    })();
</script>
<p>141.环形链表</p>
<script data-msg="141.环形链表">
    //  判断有没有环形链表
    (() => {
        const arr = createList(10);

        function createList(len){
            const arr = new Array(len);
            for (let i = len - 1; i >= 0; i--) {
                arr[i] = { value: i, next: arr[i + 1] || null };
            }
            return arr;
        }

        // console.log(arr);
        // arr[9].next = arr[3];

        function circle(node){
            //  如果没有了
            if (!node) {
                return false;
            }
            //  如果是重复了，说明闭环了
            if (node.flag) {
                return true;
            }
            //  如果没有重复
            if (node.flag === undefined) {
                node.flag = true;
            }
            return circle(node.next);
        }

        const isCircle = circle(arr[0]);
        // console.log(isCircle);

    })();
</script>
<p>160.相交链表</p>
<script data-msg="160.相交链表">
    (() => {
        function setFlag(node){
            if (!node) {
                return false;
            }
            if (node.flag) {
                return node;
            }
            node.flag = true;
            return setFlag(node.next);
        }
    })();
</script>
<p>167.两数之和2，输入有序数组</p>
<script data-msg="167.两数之和2，输入有序数组">
    (() => {
        const arr = [1, 2, 4, 5, 8, 322, 566, 881];

        function getValue(arr, target){
            const hash = {};
            for (let i = 0; i < arr.length; i++) {
                const _hashVal = hash[target - arr[i]];
                if (_hashVal === undefined) {
                    hash[arr[i]] = i;
                    continue;
                }
                return [_hashVal, i];
            }
            return null;
        }

        // const res = getValue(arr, 566 + 2);
        // console.log(res);
    })();
</script>
<p class="red">168.excel表列名称</p>
<script>
    (() => {
        const el = 'abcdefghijklmnopqrstuvwxyz'.split('');

        // console.log(el);

        function getValue(num){
            const arr = [];
            while (num > 0) {
                if (num === 26) {
                    arr.unshift(el[num - 1]);
                } else {
                    arr.unshift(el[num % (el.length) - 1]);
                }
                num = Math.floor(num / (el.length + 1));
            }
            // console.log(arr);
            return arr;
        }

        const res = getValue(701);

        // console.log(res);

        function a(n){
            let ans = '';
            while (n) {
                if (n % 26 === 0) {
                    ans += String.fromCharCode(26 + 64);
                    n = (n / 26 - 1);
                } else {
                    ans += String.fromCharCode(n % 26 + 64);
                    n = Math.floor(n / 26);
                }
            }
            return ans.split('').reverse().join('');
        }

        // console.log(a(343));
    })();
</script>
<p>171.求众数</p>
<script data-msg="171.求众数">
    (() => {
        const arr = [12, 3, 4, 5, 23, 123545, 231, 51, 2343, 5, 87, 23, 5, 6, 7, 8, 7, 6, 4, 8, 3, 3983, 31, 756, 13, 8, 42, 7, 3, 2];

        function getValue(arr){
            const hash = {};
            let max = -Infinity;
            let maxValue = 0;
            arr.forEach(function (item, index){
                hash[item] = hash[item] || 0;
                hash[item]++;
                if (max < hash[item]) {
                    max = hash[item];
                    maxValue = item;
                }
            });
            return maxValue;
        }

        const res = getValue(arr);
        // console.log(res);
    })();
</script>
<p class="red">172.阶乘后的零</p>
<script data-msg="172.阶乘后的零">
    (() => {
        function getValue(n, prev){
            prev = prev || BigInt(1);
            n = BigInt(n);
            if (n === BigInt(1)) {
                return n * prev;
            }
            if (n === BigInt(0)) {
                return 0;
            }
            prev = n * prev;
            return getValue(n - BigInt(1), prev);
        }

        function getZeroCount(n){
            n = BigInt(n);
            let _n = 0;
            while (n > BigInt(10) && n % BigInt(10) === BigInt(0)) {
                n = n / BigInt(10);
                _n++;
            }
            return _n;
        }

        const res = getValue(222);
        // console.log(res);
        // console.log(getZeroCount(res));

        function tra(n){
            let ans = 0;
            while (n) {
                n = Math.floor(n / 5);
                ans += n;
            }
            return ans;
        }

        // console.log(tra(15));
    })();
</script>
<p>189.旋转数组</p>
<script data-msg="189.旋转数组">
    (() => {
        let arr = ['1', '2', '3', '4', '5', '6', '7'];
        const len = arr.length;

        //  1.
        function getValue1(n){
            n = n % len;
            if (n === 0) {
                return;
            }
            do {
                let last = arr[len - 1];
                for (let i = len - 1; i > 0; i--) {
                    arr[i] = arr[i - 1];
                }
                arr[0] = last;
            } while (--n);
        }

        // getValue1(0);
        // console.log(arr);

        //  2.
        function getValue2(n){
            n = n % len;
            if (n === 0) {
                return;
            }
            let temp = arr.slice(-n, len);
            arr.splice(-n, n);
            Array.prototype.unshift.apply(arr, temp);
        }

        getValue2(3);
        // console.log(arr);
    })();
</script>
<p class="red">190.颠倒二进制位</p>
<script data-msg="190.颠倒二进制位">
    (() => {
        //  需理解题意
        const num = 43261596;

        function getValue1(n = 0){
            return parseInt(n.toString(2).split('').reverse().join(''), 2);
        }

        function getValue2(n){
            let str = [];
            //  先转二进制
            while (n) {
                const yu = n % 2;
                str.unshift(yu);
                n = ~~(n / 2);
            }
            return parseInt(str.reverse().join(''), 2);
        }

        // console.log(getValue1(num));
        // console.log(getValue2(num));

        //  缓存了数据
        const sum = [];
        sum[0] = 1;
        for (let i = 1; i <= 32; i++) {
            sum[i] = 2 * sum[i - 1];
        }

        // console.log(sum);

        function getValue3(n = 0){
            const temp = ('00000000000000000000000000000000' + n.toString(2)).slice(-32);
            let ans = 0;
            for (let i = 0, len = temp.length; i < len; i++) {
                if (temp[i] === '1') {
                    ans += sum[i];
                }
            }
            return ans;
        }

        // console.log(getValue3(num))
    })();
</script>
<p>191.位1的个数</p>
<script data-msg="191.位1的个数">
    (() => {
        function getValue1(n = 0){
            return n.toString(2).match(/1/ig).length;
        }

        // console.log(getValue1(65535));
        function getValue2(n){
            let ans = 0;
            while (n) {
                const yu = n % 2;
                ans += yu;
                n -= yu;
                n /= 2;
            }
            return ans;
        }
    })();
</script>
<p>198.打家劫舍</p>
<script data-msg="198.打家劫舍">
    (() => {
        const arr = [2, 43, 8, 2, 89, 0, 3, 12, 5, 8, 4, 21];

        function getValue1(){
            const data = [];
            data[0] = [];
            data[1] = [];
            data[0][0] = arr[0];
            data[1][0] = arr[1];
            console.log(data);
            for (let i = 1, len = arr.length; i < len; i++) {

            }
        }

        function getValue2(nums){
            const len = nums.length;
            if (!len) {
                return 0;
            }
            const dp = [];
            dp[0] = [];
            dp[0][0] = 0;
            dp[0][1] = nums[0];
            for (let i = 1; i < len; i++) {
                dp[i] = [];
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
                dp[i][1] = dp[i - 1][0] + nums[i];
                // console.log(JSON.parse(JSON.stringify(dp)));
            }
            return Math.max(dp[len - 1][0], dp[len - 1][1]);
        }

        function getValue3(n, total){
            n = n || 0;
            total = total || 0;
            if (n >= arr.length) {
                return total;
            }
            total += arr[n];
            // console.log(total);
            return Math.max(getValue3(n + 2, total), getValue3(n + 3, total));
        }

        // console.time('a');
        // console.log(getValue2(arr));
        // console.timeEnd('a');
        // console.time('b');
        // console.log(getValue3());
        // console.timeEnd('b');
    })();
</script>
<p>extra.爬楼梯</p>
<script data-msg="extra.爬楼梯">
    //  假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    //  每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    //  1.1 -> 1
    //  2.2 -> 11 2
    //  3.3 -> 111 12 21
    //  4.5 -> 1111 112 121 211 22
    //  5.8 -> 11111 1112 1121 1211 2111 122 212 221

    //  如果看到这儿，应该符合 层数[n-1]*2-1

    //  6.13 -> 111111 11112 11121 11211 12111 21111 1122 1212 1221 2112 2121 2211 222

    //  是斐波那契，但是为什么是？
    //  因为爬楼梯到第n层，最后一步可能是1层，也可能是两层，有且只有这两种情况。所以是n-1层步数和n-2层步数的和。
    //  问的是多少方法，所以n-1层的步数不需要最后+1，n-2也不需要+2。
    (() => {
        function getValue(n){
            if (n <= 0) {
                return 0;
            }
            if (n === 1) {
                return 1;
            }
            if (n === 2) {
                return 2;
            }
            return getValue(n - 1) + getValue(n - 2);
        }

        for (let i = 0; i < 10; i++) {
            // console.log(i, getValue(i));
        }
    })();
</script>
<p>extra.斐波那契</p>
<script data-msg="extra.斐波那契">
    (() => {
        //  1.1
        //  2.2
        //  3.3
        //  4.5
        //  5.8
        //  6.13
        function f(n){
            let a = 0;
            let b = 1;
            if (n <= 1) {
                return 1;
            }
            while (--n) {
                let c = a;
                a = b;
                b += c;
            }
            return a + b;
        }

        for (let i = 0; i < 10; i++) {
            // console.log(f(i));
        }

        /**
         * @param:n,次数
         * @param:_total,前一次的
         * @param:total，当前总数
         * */
        function f1(n, _total, total){
            _total = _total || 1;
            total = total || 1;
            if (n <= 1) {
                return total;
            }
            return f1(n - 1, total, _total + total);
        }

        for (let i = 0; i < 10; i++) {
            // console.log(f1(i));
        }
    })();
</script>
<p>202.快乐数</p>
<script data-msg="202.快乐数">
    (() => {
        function getValue(n){
            let arr = [];
            let _n = n;
            do {
                let m = 0;
                n = n.toString();
                for (let i = n.length - 1; i >= 0; i--) {
                    m += Math.pow(+n[i], 2);
                }
                n = m;
                if (arr.indexOf(m) !== -1) {
                    return false;
                }
                if (m === 1) {
                    console.log(_n);
                    return true;
                }
                arr.push(m);
            } while (1);
        }

        //  1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97, 100。
        for (let i = 0; i <= 100; i++) {
            // getValue(i);
        }
    })();
</script>
<p>203.删除链表中的节点</p>
<script data-msg="203.删除链表中的节点">
    (() => {
        let _arr = [];

        function deleteValue(value){
            for (let i = 0; i < _arr.length; i++) {
                if (_arr[i].value === value) {
                    _arr.splice(i, 1);
                    if (_arr[i - 1]) {
                        if (_arr[i]) {
                            _arr[i - 1].next = _arr[i];
                        }
                    } else {
                        _arr[i].isHead = true;
                    }
                    break;
                }
            }
        }
    })();
</script>
<p>204.计数质数</p>
<script data-msg="204.计数质数">
    (() => {
        //  key：第几个数，value：有几个质数
        const arr = {
            1: 0,
        };

        function getValue(n){
            if (arr[n] !== undefined) {
                return arr[n];
            }
            arr[n] = arr[n - 1];
            let _n = 2;
            const s_n = Math.sqrt(n);
            let isHe = false;
            while (_n <= s_n) {
                if (n % _n === 0) {
                    isHe = true;
                    break;
                }
                _n++;
            }
            if (!isHe) {
                arr[n] = arr[n - 1] + 1;
            }
            return arr.length;
        }

        for (let i = 1; i < 100; i++) {
            let res = getValue(i);
            // console.log(res);
        }
        // console.log(arr);
        // console.log(getValue(10))
    })();
</script>
<p>205.同构字符串</p>
<script data-msg="205.同构字符串">
    (() => {
        function getValue(str1, str2){
            str1 = str1.toString();
            str2 = str2.toString();
            let obj1 = {};
            let obj2 = {};
            for (let i = 0; i < str1.length; i++) {
                obj1[str1[i]] = (obj1[str1[i]] || 0) + 1;
                obj2[str2[i]] = (obj2[str2[i]] || 0) + 1;
            }
            // console.log(obj1);
            // console.log(obj2);
            return obj1.toString() === obj2.toString();
        }

        const res = getValue(12122, 'ababb');
        // console.log(res);
    })();
</script>
<p>217.存在重复元素</p>
<script data-msg="217.存在重复元素">
    (() => {
        function getValue(arr){
            const hash = {};
            for (let i = 0; i < arr.length; i++) {
                //  重复
                if (hash[arr[i]]) {
                    return true;
                }
                hash[arr[i]] = 1;
            }
        }

        const arr = [1, 2, 3, 5, 4, 3];
        // console.log(getValue(arr));
    })();
</script>
<p>219.存在重复元素二</p>
<script data-msg="219.存在重复元素二">
    (() => {
        function getValue(arr, _dif){
            const hash = {};
            for (let i = 0; i < arr.length; i++) {
                //  如果有重复
                if (hash[arr[i]]) {
                    //  判断距离
                    if (hash[arr[i]] + _dif <= i) {
                        console.log(hash, arr[i]);
                        return true;
                    }
                }
                //  是新的数
                hash[arr[i]] = i;
            }
            console.log(hash);
            return false;
        }

        const arr = [21, 34, 3, 63, 21, 2, 4, 73, 12, 1, 3, 1, 3];
        // const res = getValue(arr, 3);
        // console.log(res);
    })();
</script>
<p>225.用队列实现栈</p>
<script data-msg="225.用队列实现栈">
    (() => {
        function Stack(){
            this.arr = [];
        }

        Stack.prototype.push = function (x){
            this.arr.push(x);
        };
    })();
</script>
<p>226.反转二叉树</p>
<script data-msg="226.反转二叉树">
    (() => {
        const obj = {
            value: 4,
            prev: {
                value: 2,
                prev: {
                    value: 1,
                },
            },
            next: {
                value: 6,
                prev: {
                    value: 5,
                }
            }
        };

        function getValue(obj){
            const prev = obj.prev;
            obj.prev = obj.next || null;
            obj.next = prev || null;
            obj.prev && getValue(obj.prev);
            obj.next && getValue(obj.next);
        }

        // console.log(JSON.parse(JSON.stringify(obj)));
        getValue(obj);
        // console.log(obj);
    })();
</script>
<p>231.2的幂</p>
<script data-msg="231.2的幂">
    (() => {
        function getValue(n){
            return ((Math.log(n) / Math.log(2)) % 1) === 0;
        }

        // console.log(getValue(17))
    })();
</script>
<p>232.用栈实现队列</p>
<script data-msg="232.用栈实现队列">
    (() => {
        //  略
    })();
</script>
<p>234.回文链表</p>
<script data-msg="234.回文链表">
    (() => {
        const obj = {
            value: 1,
            next: {
                value: 2,
                next: {
                    value: 3,
                    next: {
                        value: 2,
                        next: {
                            value: 1
                        }
                    }
                }
            }
        };

        function getValue(obj){
            let str = '';
            do {
                str += obj.value;
                obj = obj.next;
            } while (obj);
            for (let i = 0; i < str.length; i++) {
                if (str[i] !== str[str.length - 1 - i]) {
                    return false;
                }
            }
            return true;
        }

        const res = getValue(obj);
        // console.log(res);
    })();
</script>
<p class="red">235.二叉搜索树的最近公共祖先</p>
<script data-msg="235.二叉搜索树的最近公共祖先">
    (() => {
        //  二叉搜索树是按大小排序的
        const next = {
            value: 11,
            prev: {
                value: 10,
            }
        };
        const prev = {
            value: 8,
        };
        const obj = {
            value: 5,
            prev: {
                value: 3,
                next: {
                    value: 4,
                },
            },
            next: {
                value: 9,
                prev: {
                    value: 7,
                    next: next
                },
                next: {
                    value: 14,
                    prev: prev,
                }
            }
        };
        const res = getValue(obj, prev, next);

        // console.log(res);

        function getValue(obj, prev, next){
            let value = obj.value;
            let pValue = prev.value;
            let nValue = next.value;
            //  夹击
            if (value > pValue && value < nValue) {
                return obj;
            }
            //  向右查找
            if (value < pValue) {
                return getValue(obj.next, prev, next);
            }
            if (value > nValue) {
                return getValue(obj.prev, prev, next);
            }
        }
    })();
</script>
<p>237.删除链表节点</p>
<script data-msg="237.删除链表节点">
    (() => {
        //  略
    })();
</script>
<p>242.有效的字母异位词</p>
<script data-msg="242.有效的字母异位词">
    (() => {
        //  就是用的字母都一样，排序变了
        function getValue(str1, str2){
            if (str1.length !== str2.length) {
                return false;
            }
            return (str1.split('').sort().join() === str2.split('').sort().join());
        }

        const res = getValue('323221,', '221,321');
        // console.log(res);
    })();
</script>
<p class="red">257.二叉树的所有路径</p>
<script data-msg="257.二叉树的所有路径">
    (() => {
        //  略，有几个叶子节点就有几个路径
    })();
</script>
<p>258.各位相加</p>
<script data-msg="258.各位相加">
    (() => {
        function getValue1(n){
            n = n.toString();
            while (n >= 10) {
                n = n.toString();
                let res = 0;
                for (let i = 0; i < n.length; i++) {
                    res += +n[i];
                }
                n = res;
            }
            return n;
        }

        //  谁tm知道了？
        function getValue2(n){
            return 1 + (n - 1) % 9;
        }

        // const res = getValue1(2273);
        const res = getValue2(2273);
        // console.log(res);
    })();
</script>
<p class="red">263.丑数</p>
<script data-msg="263.丑数">
    (() => {
        function getValue(n){
            //  用这些因数除，直到除到除不尽
            for (let i = 0; i < arr.length; i++) {
                while (n % arr[i] === 0) {
                    n /= arr[i];
                }
            }
            //  除不尽就是有其他到因数
            return n === 1;
        }

        //  只有这些因数
        const arr = [2, 3, 5];
        const res = getValue(128);
        // console.log(res);
    })();
</script>
<p>268.缺失数字</p>
<script data-msg="268.缺失数字">
    (() => {
        const arr = [9, 6, 4, 2, 3, 5, 7, 0, 1];

        function getValue(arr){
            const obj = {};
            for (let i = 0; i < arr.length; i++) {
                obj[arr[i]] = 1;
            }
            for (let i = 0; i <= arr.length; i++) {
                if (obj[i] === undefined) {
                    return i;
                }
            }
        }

        const res = getValue(arr);
        // console.log(res);
    })();
</script>
<p>278.第一个错误的版本</p>
<script data-msg="278.第一个错误的版本">
    (() => {
        return;
        //  用了二分法，注意判断 <=
        const solution = function (isBadVersion){
            return function (n){
                let start = 1;
                let end = n;
                while (start <= end) {
                    const mid = Math.floor((start + end) / 2);
                    //  如果是错的，那么错的可能在更前面
                    if (!isBadVersion(mid)) {
                        end = mid - 1;
                    } else {
                        start = mid + 1;
                    }
                }
                return start;
            };
        };
        const fn = solution(function (n){
            return Math.random() > 0.5;
        });
        console.log(fn(14));
    })();
</script>
<p>283.移动零</p>
<script>
    (() => {
        return;
        const arr = ['0', '2', '3', '0', '0', '2', '3', '0', '2', '3', '0', '2', '3', '2', '3', '4', '0', '3', '4', '0', '4', '3', '0', '3', '4', '2', '0', '2', '3', '1', '2', '3', '0', '3', '4', '0', '3', '4', '5', '0', '0', '4', '5', '0', '4', '5', '0', '5', '4', '0', '2', '4', '2', '1', '3', '0', '1', '2', '3', '0', '0', '1', '3', '0', '2', '3', '0'];

        function moveZero(arr){
            let count = 0;
            const len = arr.length;
            for (let i = 0; i < len - count; i++) {
                if (Number(arr[i]) === 0) {
                    arr.splice(i, 1);
                    arr.push(0);
                    i--;
                    count++;
                }
            }
            // console.log(len - count);
            return arr;
        }

        console.log(moveZero(arr));
    })();
</script>
<p>290. 单词规律</p>
<script data-msg="290. 单词规律">
    (() => {
        return;

        //  pattern = "abba", str = "dog cat cat dog"
        function wordLaw(pattern, str){
            const patternArr = pattern.split('');
            const strArr = str.split(' ');
            const strMap = {};
            patternArr.forEach((key, index) => {
                strMap[key] = strArr[index];
            });
            const patternStr = patternArr.map(item => {
                return strMap[item];
            }).join(' ');
            return patternStr === str;
        }

        const result = wordLaw('abbaccc', 'dog cat cat dog a a a');
        console.log(result);
    })();
</script>
<p>292. Nim 游戏</p>
<script data-msg="292. Nim 游戏">
    (() => {
        return;

        /**
         * @return:boolean
         * */
        function canWinNim(n){
            return n % 4 !== 0;
        }

        const result = canWinNim(3);
        console.log(result);
    })();
</script>
<p>299. 猜数字游戏</p>
<script data-msg="299. 猜数字游戏">
    (() => {
        return;
        //   secret = "1123", guess = "0111"
        const guessFn = (secret, guess) => {
            //  完全正确
            const A = [];
            //  秘密的剩余的
            const reSec = [];
            //  位置错误
            let B = {};
            for (let i = 0; i < secret.length; i++) {
                if (secret[i] === guess[i]) {
                    A.push(i);
                } else {
                    reSec.push(secret[i]);
                    B[guess[i]] = 1;
                }
            }

            return {
                A: A.length,
                B: reSec.reduce((prev, current) => {
                    const res = prev + (B[current] || 0);
                    delete B[current];
                    return res;
                }, 0),
            };
        };
        const result = guessFn('112341', '011000');
        // const result = guessFn('1807', '7810');
        console.log(result);
    })();
</script>
<p>303. 区域和检索 - 数组不可变</p>
<script data-msg="303. 区域和检索 - 数组不可变">
    (() => {
        return;
        const arr = [-2, 0, 3, -5, 2, -1];
        const map = {};

        function sumRange(a, b){
            const key = `${a},${b}`;
            if (map[key]) {
                console.log(map, key);
                return map[key];
            }
            const res = arr.slice(a, b + 1).reduce((prev, item) => {
                return prev + item;
            }, 0);
            map[key] = res;
            return res;
        }

        console.log(sumRange(0, 2));
        console.log(sumRange(0, 2));
        console.log(sumRange(0, 2));
        console.log(sumRange(2, 5));
    })();
</script>
<p>326. 3的幂</p>
<script data-msg="326. 3的幂">
    (() => {
        return;

        function getValue(n){
            while (n >= 3 && (n /= 3) >= 3) {

            }
            return (n % 3 === 1);
        }

        for (let i = 0; i < 100; i++) {
            if (getValue(i)) {
                console.log(i);
            }
        }
    })();
</script>
<p>342. 4的幂</p>
<script data-msg="342. 4的幂">
    (() => {
        return;

        function isPowerOfFour(n){
            while (n >= 4 && (n % 1 === 0)) {
                n /= 4;
            }
            return (n === 1);
        }

        for (let i = 0; i < Math.pow(2, 22); i++) {
            if (isPowerOfFour(i)) {
                console.log(i);
            }
        }
    })();
</script>
<p>345. 反转字符串中的元音字母</p>
<script data-msg="345. 反转字符串中的元音字母">
    (() => {
        return;
        const map = {
            a: true,
            e: true,
            i: true,
            o: true,
            u: true,
        };

        // function getValue(str){
        //     const _str = str.split('');
        //     //  str里的元音音素
        //     const yArr = [];
        //     _str.forEach((item, index) => {
        //         if (map[item]) {
        //             yArr.push(item);
        //         }
        //     });
        //     return _str.map((item, index) => {
        //         if (map[item]) {
        //             return yArr.pop();
        //         }
        //         return item;
        //     }).join('');
        // }

        function getValue(str){
            let start = 0;
            let end = 0;
            startLabel:for (let i = 0; i < str.length - end; i++) {
                if (!map[str[i]]) {
                    continue;
                }
                start = i;
                for (let j = str.length - 1 - end; j > i; j--) {
                    if (!map[str[j]]) {
                        continue;
                    }
                    end = str.length - j;
                    str = str.slice(0, i) + str[j] + str.slice(i + 1, j) + str[i] + str.slice(j + 1);
                    continue startLabel;
                }

            }
            return str;
        }

        console.log(getValue('kobe bryant lebron james micheal jordan'));
        console.log(getValue('kabo bryant lebrin jemas mocheal jerdon'));
    })();
</script>
<p>349. 两个数组的交集</p>
<script data-msg="349. 两个数组的交集">
    (() => {
        return;
        const nums1 = [1, 2, 2, 1];
        const nums2 = [2, 2];

        function getValue(n1, n2){
            const map = {};
            n1.forEach(item => {
                map[item] = true;
            });
            const result = n2.filter(item => {
                if (map[item]) {
                    delete map[item];
                    return item;
                }
            });
            return result;
        }

        console.log(getValue(nums1, nums2));
    })();
</script>
<p>367. 有效的完全平方数</p>
<script data-msg="367. 有效的完全平方数">
    (() => {
        return;

        //  不要使用任何内置的库函数
        function isPowerNum(n){
            console.log(`输入${n}`);
            //  结果的位数
            let w = Math.floor((n.toString().length + 1) / 2);
            console.log(`结果的位数:${w}`);
            const result = new Array(w).fill(0);
            while (w--) {
                //  从1-9去试试
                for (let i = 1; i < 10; i++) {
                    result[result.length - 1 - w] = i * Math.pow(10, w);
                    const resValue = Math.pow(result.reduce(((previousValue, currentValue1) => previousValue + currentValue1)), 2);
                    //  如果不足
                    if (resValue < n) {
                        // 继续
                        continue;
                    } else if (resValue === n) {
                        console.log(`有${result}`);
                        //  找到了
                        return true;
                    } else {
                        result[result.length - 1 - w] = (i - 1) * Math.pow(10, w);
                        break;
                    }
                }
            }
            console.log(`无${result}`);
            return false;
        }

        isPowerNum(Number.MAX_SAFE_INTEGER);
    })();
</script>
<p>371. 两整数之和</p>
<script data-msg="371. 两整数之和">
    (() => {
        return;
        const res = getSum(12, 21);
        console.log(res);

        function getSum(a, b){
            //  保证a>b
            if (b > a) {
                let c = a;
                a = b;
                b = c;
            }
            let bs_a = ('0' + a.toString(2)).split('').reverse();
            let bs_b = b.toString(2).split('').reverse();
            //  进位符号
            let isOver = false;
            const resultArr = [];
            // console.log(bs_b, bs_a);
            //  循环大二进制数
            bs_a.forEach((item, index) => {
                // debugger
                let _arr = [];
                if (item === '1') {
                    _arr.push(1);
                }
                if (bs_b[index] === '1') {
                    _arr.push(1);
                }
                if (isOver) {
                    _arr.push(1);
                }
                switch (_arr.length) {
                    case 0:
                        isOver = false;
                        resultArr.push(0);
                        break;
                    case 1:
                        isOver = false;
                        resultArr.push(1);
                        break;
                    case 2:
                        isOver = true;
                        resultArr.push(0);
                        break;
                    case 3:
                        isOver = true;
                        resultArr.push(1);
                        break;
                }
            });
            return parseInt(resultArr.reverse().join(''), 2);
        }

    })();
</script>
<p>374. 猜数字大小</p>
<script data-msg="374. 猜数字大小">
    (() => {
        return;
        const res = getValue(2132, 1321);
        console.log(res);

        //  二分
        function getValue(n, guessValue){
            let min = 1;
            let max = n;
            while (true) {
                let center = Math.floor((min + max) / 2);
                if (center === guessValue) {
                    return center;
                }
                //  需要减小
                if (center > guessValue) {
                    max = center - 1;
                }
                //  需要增加
                if (center < guessValue) {
                    min = center + 1;
                }
            }
        }
    })();
</script>
<p>383. 赎金信</p>
<script data-msg="383. 赎金信">
    (() => {
        return;
        const a = canConstruct('a', 'b');
        const b = canConstruct('aa', 'ab');
        const c = canConstruct('aa', 'aab');
        console.log(a, b, c);

        function canConstruct(a, b){
            const mapA = {};
            b.split('').forEach(item => {
                mapA[item] = mapA[item] || 0;
                mapA[item]++;
            });
            let arr = a.split('');
            for (let i = 0; i < arr.length; i++) {
                if (mapA[arr[i]] === undefined || mapA[arr[i]] === 0) {
                    return false;
                }
                mapA[arr[i]]--;
            }
            return true;
        }
    })();
</script>
<p>387. 字符串中的第一个唯一字符</p>
<script data-msg="387. 字符串中的第一个唯一字符">
    (() => {
        return;
        const a = firstUniqChar('leetcode');
        const b = firstUniqChar('loveleetcode');
        console.log(a);
        console.log(b);

        function firstUniqChar(str){
            const map = {};
            for (let i = 0; i < str.length; i++) {
                map[str[i]] = map[str[i]] || 0;
                map[str[i]]++;
                if (map[str[i]] > 1) {
                    const char = str[i];
                    str = str.replace(new RegExp(char, 'ig'), ' ');
                }
            }
            return str.indexOf(str.trim()[0]);
        }

        //  或者
        //  indexOf === lastIndexOf

    })();
</script>
<p>389. 找不同</p>
<script data-msg="389. 找不同">
    (() => {
        return;
        const a = 'abd';
        const b = 'abcd';

        const res = findTheDifference(a, b);
        console.log(res);

        // function findTheDifference(s, t){
        //     for (let i = 0; i < s.length; i++) {
        //         t = t.replace(new RegExp(s[i], 'ig'), '');
        //     }
        //     return t;
        // }

        //  位运算
        function findTheDifference(s, t){
            const total = s + t;
            let i = 0;
            let res = 0;
            while (i < total.length) {
                res ^= total.charCodeAt(i);
                console.log(res);
                i++;
            }
            return String.fromCharCode(res);
        }
    })();
</script>
<p>392. 判断子序列</p>
<script data-msg="392. 判断子序列">
    (() => {
        return;
        //  就你叫贪心算法啊？双指针法由于要遍历过多的t，不好
        //  t长，s短
        function isSubsequence(t, s){
            let index = 0;
            for (let i = 0; i < s.length; i++) {
                index = t.indexOf(s[i], index);
                if (index === -1) {
                    return false;
                }
                console.log(index);
            }
            return true;
        }

        const t = 'feawfgnajwiohgobgouhovnbfrjfiebhjanbjfnnjfanruiqouhjnmfjighobnfnrmbnefnjmbaefnmnjafjbnfrbhfnjfjbhnjbfhjhfkdjbfhjhjbhfeawfgnajwiohgobgouhovnbfrjfiebhjanbjfnnjfanruiqouhjnmfjighobnfnrmbnefnjmbaefnmnjafjbnfrbhfnjfjbhnjbfhjhfkdjbfhjhjbhfeawfgnajwiohgobgouhovnbfrjfiebhjanbjfnnjfanruiqouhjnmfjighobnfnrmbnefnjmbaefnmnjafjbnfrbhfnjfjbhnjbfhjhfkdjbfhjhjbh';
        const s = 'fbeufbeufbeu';
        const result = isSubsequence(t, s);
        console.log(result);
    })();
</script>
<p class="red">401. 二进制手表</p>
<script data-msg="401. 二进制手表">
    (() => {
        return;
        var readBinaryWatch = function (num){
            const res = [];
            const hourstrs = [['0'], ['1', '2', '4', '8'], ['3', '5', '6', '9', '10'], ['7', '11']];
            const minstrs = [
                ['00'],
                ['01', '02', '04', '08', '16', '32'],
                ['03', '05', '06', '09', '10', '12', '17', '18', '20', '24', '33', '34', '36', '40', '48'],
                ['07', '11', '13', '14', '19', '21', '22', '25', '26', '28', '35', '37', '38', '41', '42', '44', '49', '50', '52', '56'],
                ['15', '23', '27', '29', '30', '39', '43', '45', '46', '51', '53', '54', '57', '58'],
                ['31', '47', '55', '59']
            ];
            for (let i = 0; i <= Math.min(3, num); i++) {
                if (num - i > 5) {
                    continue;
                }
                const hstr = hourstrs[i];
                const mstr = minstrs[num - i];
                for (let j = 0; j < hstr.length; j++) {
                    for (let k = 0; k < mstr.length; k++) {
                        res.push(hstr[j] + ':' + mstr[k]);
                    }
                }
            }
            return res;
        };
        const res = readBinaryWatch(8);
        console.log(res);
    })();
</script>
<p>404. 左叶子之和</p>
<script data-msg="404. 左叶子之和">
    (() => {
        return;

        function sumOfLeftLeaves(node){
            let sum = 0;

            function fn(node){
                if (node === null) {
                    return 0;
                }
                if (node.left && node.left.left === null && node.left.right === null) {
                    sum += node.left;
                }
                fn(node.left);
                fn(node.right);
            }

            fn(node);
            return sum;
        }
    })();
</script>
<p>405. 数字转换为十六进制数</p>
<script data-msg="405. 数字转换为十六进制数">
    (() => {
        return;

        function toHex(n){
            const arr = ['a', 'b', 'c', 'd', 'e', 'f'];
            let flag = n > 0;
            if (flag) {
                const res = [];
                while (1) {
                    res.unshift(n % 16);
                    if (n < 16) {
                        break;
                    }
                    n = Math.floor(n / 16);
                }
                return res.map(item => {
                    switch (Number(item)) {
                        case 10:
                            item = arr[0];
                            break;
                        case 11:
                            item = arr[1];
                            break;
                        case 12:
                            item = arr[2];
                            break;
                        case 13:
                            item = arr[3];
                            break;
                        case 14:
                            item = arr[4];
                            break;
                        case 15:
                            item = arr[5];
                            break;
                    }
                    return item;
                }).join('');
            }
            let str = (-n - 1).toString(2);
            while (str.length < 32) {
                str = '0' + str;
            }
            let _str = '';
            for (let i = 0; i < str.length; i++) {
                if (str[i] === '0') {
                    _str += '1';
                    continue;
                }
                if (str[i] === '1') {
                    _str += '0';
                }
            }
            return toHex(parseInt(_str, 2));
        }

        const res = toHex(-1);
        console.log(res);
    })();
</script>
<p>409. 最长回文串,给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<script data-msg="409. 最长回文串,给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串">
    (() => {
        return;

        function longestPalindrome(str){
            let sum = 0;
            for (let i = 0; i < str.length; i++) {
                const index = str.lastIndexOf(str[i]);
                //  奇数
                if (index === i) {
                    continue;
                }
                str = str.slice(0, i) + str.slice(i + 1, index) + str.slice(index + 1);
                sum += 2;
                i--;
            }
            if (str.length % 2 === 1) {
                sum++;
            }
            return sum;
        }

        const res = longestPalindrome('dccaccd');
        console.log(res);
    })();
</script>
<p>412. Fizz Buzz.写一个程序，输出从 1 到 n 数字的字符串表示。 1. 如果 n 是3的倍数，输出“Fizz”； 2. 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出
    “FizzBuzz”。</p>
<script data-msg="412. Fizz Buzz.写一个程序，输出从 1 到 n 数字的字符串表示。 1. 如果 n 是3的倍数，输出“Fizz”； 2. 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。">
    (() => {
        return;

        function fizzBuzz(n){
            const arr = [];
            for (let i = 1; i <= n; i++) {
                if (i % 3 !== 0 && i % 5 !== 0) {
                    arr.push(i.toString());
                    continue;
                }
                let str = '';
                if (i % 3 === 0) {
                    str += 'Fizz';
                }
                if (i % 5 === 0) {
                    str += 'Buzz';
                }
                arr.push(str);
            }
            return arr;
        }

        console.log(fizzBuzz(15));
    })();
</script>
<p>414. 第三大的数.给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p>
<script data-msg="414. 第三大的数.给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。">
    (() => {
        return;
        const arr = [1, 2, -2147483648, -2147483648];

        function thirdMax(arr){
            let max = -Infinity;
            let second = -Infinity;
            let third = -Infinity;
            for (let key of arr) {
                if (key > max) {
                    third = second;
                    second = max;
                    max = key;
                    continue;
                }
                if (key > second) {
                    third = second;
                    second = key;
                    continue;
                }
                if (key > third) {
                    third = key;
                }
            }
            if (String.prototype.indexOf.call(arr, third) !== String.prototype.lastIndexOf.call(arr, third)) {
                return max;
            }
            return third;
        }

        const res = thirdMax(arr);
        console.log(res);
    })();
</script>
<p>415. 字符串相加.给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<script data-msg="415. 字符串相加.给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。">
    (() => {
        return;
        const a = '23456768593847569893457968493407923456768593847569893457968493407921';
        const b = '485784039894597807938628094823456768593847569893457968493407948578';

        function addStrings(a, b){
            //  a比较大
            if (b.length > a.length) {
                const c = a;
                a = b;
                b = c;
            }
            let res = '';
            let carryOver = 0;
            while (a.length) {
                let _a = a[a.length - 1];
                let _b = b[b.length - 1] || 0;
                const sum = Number(_a) + Number(_b) + carryOver;
                if (sum > 9) {
                    carryOver = 1;
                } else {
                    carryOver = 0;
                }
                res = sum.toString().slice(-1) + res;
                a = a.slice(0, -1);
                b = b.slice(0, -1);
            }
            return res;
        }

        const res = addStrings(a, b);
        console.log(res);

        console.log(BigInt(a) + BigInt(b));
    })();
</script>
<p>434. 字符串中的单词数.统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<script data-msg="434. 字符串中的单词数.统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。">
    (() => {
        return;

        function countSegments(s){
            let max = 0;
            let current = 0;
            while (s.length) {
                if (s.substring(0, 1) === ' ') {
                    current = 0;
                } else {
                    current++;
                }
                max = Math.max(max, current);
                s = s.slice(1);
            }
            return max;
        }

        const res = countSegments('输入: "Hello, my name is John"');
        console.log(res);
    })();
</script>
<p class="red">437. 路径总和 III</p>
<script></script>
<p>441. 排列硬币.你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数，并且在32位有符号整型的范围内。</p>
<script data-msg="441. 排列硬币.你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数，并且在32位有符号整型的范围内。">
    (() => {
        return;

        function arrangeCoins(n){
            //  个数
            let i = 0;
            //  层数
            let c = 0;
            while (1) {
                c++;
                i += c;
                if (i > n) {
                    return c - 1;
                }
            }
        }

        const res = arrangeCoins(21);
        console.log(res);

    })();
</script>
<p>443. 压缩字符串.给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。</p>
<script data-msg="443. 压缩字符串.给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。">
    (() => {
        return;

        function compress(arr){
            let str = arr.join('');
            arr.length = 0;
            while (str.length) {
                const current = str[0];
                const index = arr.indexOf(current);
                if (index === -1) {
                    arr.push(current);
                } else {
                    if (Number(arr[index + 1])) {
                        arr[index + 1] = (Number(arr[index + 1]) + 1).toString();
                    } else {
                        arr.splice(index + 1, 0, '2');
                    }
                }
                str = str.slice(1);
            }
            let sum = 0;
            arr.forEach(item => {
                sum += item.length;
            });
            return sum;
        }

        const arr = ['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'];
        const res = compress(arr);
        console.log(res);
    })();
</script>
<p class="red">447. 回旋镖的数量,给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。
    找到所有回旋镖的数量。你可以假设 n 最大为
    500，所有点的坐标在闭区间 [-10000, 10000] 中。</p>
<script data-msg="447. 回旋镖的数量,给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。"></script>
<p>448. 找到所有数组中消失的数字,给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。
    您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<script data-msg="448. 找到所有数组中消失的数字,给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。">
    (() => {
        return;

        function findDisappearedNumbers(arr){
            let i = 1;
            let res = [];
            while (i < arr.length) {
                if (arr.indexOf(i) === -1) {
                    res.push(i);
                }
                i++;
            }
            return res;
        }

        const res = findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]);
        console.log(res);
    })();
</script>
<p>453. 最小移动次数使数组元素相等，给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。</p>
<script data-msg="453. 最小移动次数使数组元素相等，给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。">
    (() => {
        return;

        function minMoves(arr){
            const min = Math.min.apply(null, arr);
            const sum = arr.reduce((prev, current) => {
                return prev + current - min;
            }, 0);
            return sum;
        }

        const res = minMoves([1, 1, 2, 6, 7]);
        console.log(res);
    })();
</script>
<p>455. 分发饼干，假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果
    sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<script data-msg="455. 分发饼干，假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。">
    (() => {
        return;

        function findContentChildren(children, pie){
            children = children.sort(sort);
            pie = pie.sort(sort);
            let i = 0;
            let j = 0;
            let s = 0;
            while (i < children.length && j < pie.length) {
                if (pie[j] >= children[i]) {
                    j++;
                    i++;
                    s++;
                } else {
                    i++;
                }
            }
            return s;
        }

        //  从大到小排序
        function sort(a, b){
            return b - a;
        }

        const res = findContentChildren([1, 2], [1, 2, 3]);
        console.log(res);
    })();
</script>
<p>459. 重复的子字符串，给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<script data-msg="459. 重复的子字符串，给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。">
    (() => {
        return;

        function repeatedSubstringPattern(str){
            let i = 1;
            let len = str.length;
            while (i < Math.floor(len / 2) + 1) {
                //  如果除不尽
                if (len % 2 !== 0) {
                    i++;
                    continue;
                }
                let _str = ''.padEnd(len, str.slice(0, i));
                if (_str === str) {
                    return true;
                }
                i++;
            }
            return false;
        }

        const str = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';
        console.log(repeatedSubstringPattern(str));
    })();
</script>
<p>461. 汉明距离，两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<script data-msg="461. 汉明距离，两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。">
    (() => {
        return;

        function hammingDistance(a, b){
            let bin = a^b;
            let s = 0;
            while (bin) {
                if (bin % 2 === 1) {
                    s++;
                }
                bin = Math.floor(bin / 2);
            }
            return s;
        }

        const res = hammingDistance(5, 4);
        console.log(res);
    })();
</script>
<p>463. 岛屿的周长，给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
    网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1
    的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<script data-msg="463. 岛屿的周长，给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。">
    (() => {
        return;

        function islandPerimeter(grid){
            let c = 0;
            //  层
            for (let i = 0; i < grid.length; i++) {
                //  列
                for (let j = 0; j < grid[i].length; j++) {
                    //  是陆地
                    if (grid[i][j] === 1) {
                        //  判断上下左右，如果是零，则+1
                        //  左右一定有
                        if (grid[i][j - 1] !== 1) {
                            c++;
                        }
                        if (grid[i][j + 1] !== 1) {
                            c++;
                        }
                        if (!grid[i - 1] || grid[i - 1][j] !== 1) {
                            c++;
                        }
                        if (!grid[i + 1] || grid[i + 1][j] !== 1) {
                            c++;
                        }
                    }
                }
            }
            return c;
        }

        const grid = [
            [0, 1, 0, 0],
            [1, 1, 1, 0],
            [0, 1, 0, 0],
            [1, 1, 0, 0]];
        const res = islandPerimeter(grid);
        console.log(res);
    })();
</script>
<p>475. 供暖器，冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。
    所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。</p>
<script data-msg="475. 供暖器，冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。">
    (() => {
        return;
        //  暴力循环法，不好
        // function findRadius(houses, heaters){
        //     const range = [];
        //     let r = 1;
        //     while (1) {
        //         range.length = 0;
        //         for (let i = 0; i < heaters.length; i++) {
        //             range.push([heaters[i] - r, heaters[i] + r]);
        //         }
        //         let isInNum = 0;
        //         for (let i = 0; i < houses.length; i++) {
        //             for (let j = 0; j < range.length; j++) {
        //                 if (houses[i] >= range[j][0] && houses[i] <= range[j][1]) {
        //                     isInNum++;
        //                     break;
        //                 }
        //             }
        //         }
        //         if (isInNum === houses.length) {
        //             return r;
        //         }
        //         r++;
        //     }
        // }

        //  找到每个房子最近的那个，再获得其中最远的那个
        // function findRadius(houses, heaters){
        //     houses = houses.sort(sort);
        //     heaters = heaters.sort(sort);
        //     let max = 1;
        //     houses.forEach(item => {
        //         for (let i = 0; i < heaters.length; i++) {
        //             heaters[i + 1] = heaters[i + 1] || Infinity;
        //             if (Math.abs(item - heaters[i]) < Math.abs(item - heaters[i + 1])) {
        //                 max = Math.max(max, Math.abs(item - heaters[i]));
        //                 return;
        //             }
        //         }
        //     });
        //     return max;
        // }

        //  双指针法
        function findRadius(houses, heaters){
            let max = 1;
            let i = 0;
            let j = 0;
            houses = houses.sort(sort);
            heaters = heaters.sort(sort);
            while (i < houses.length && j < heaters.length) {
                heaters[j + 1] = heaters[j + 1] || Infinity;
                //  如果左侧没有暖气
                if (houses[i] <= heaters[j]) {
                    max = Math.max(max, Math.abs(houses[i] - heaters[j]));
                    i++;
                    continue;
                }
                //  如果左右都有暖气
                if (houses[i] > heaters[j]) {
                    max = Math.max(max, Math.min(Math.abs(houses[i] - heaters[j]), Math.abs(houses[i] - heaters[j + 1])));
                    i++;
                    //  如果左面的比右面的距离大
                    if (Math.abs(houses[i] - heaters[j]) >= Math.abs(houses[i] - heaters[j + 1])) {
                        j++;
                    }
                }
                //  右侧一定有暖气
            }
            return max;
        }

        function sort(a, b){
            return a - b;
        }

        const houses = [-5, 2, 10, 14];
        const heaters = [1, 11];
        const res = findRadius(houses, heaters);
        console.log(res);
    })();
</script>
<p>476. 数字的补数。给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p>
<script data-msg="476. 数字的补数。给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。">
    (() => {
        return;

        function findComplement(num){
            const b_num = num.toString(2);
            let str = '';
            for (let i = 0; i < b_num.length; i++) {
                str += (Number(b_num[i]) === 0) ? 1 : 0;
            }
            return parseInt(str, 2);
        }

        console.log(findComplement(2));
    })();
</script>
<p>482. 密钥格式化，有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。 给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K
    个字符；而第一个分组中，至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。 给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<script data-msg="482. 密钥格式化，有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。 给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符；而第一个分组中，至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。 给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。">
    (() => {
        return;

        function licenseKeyFormatting(S, K){
            let str = S.toUpperCase().split('-').join('');
            let res = '';
            while (str.length > K) {
                const current = str.substr(-K);
                res = `${current}-${res}`;
                str = str.slice(0, str.length - K);
            }
            res = `${str}-${res}`;
            if (res[res.length - 1] === '-') {
                res = res.slice(0, res.length - 1);
            }
            return res;
        }

        // const res = licenseKeyFormatting('5F3Z-2e-9-w', 4);
        const res = licenseKeyFormatting('2-5g-3-J', 2);
        console.log(res);
    })();
</script>
<p>485. 最大连续1的个数，给定一个二进制数组， 计算其中最大连续1的个数。</p>
<script data-msg="485. 最大连续1的个数，给定一个二进制数组， 计算其中最大连续1的个数。">
    (() => {
        return;

        function findMaxConsecutiveOnes(nums){
            let max = 0;
            let sum = 0;
            nums.reduce((prev, current) => {
                if (prev === 0) {
                    sum = 0;
                }
                if (current === 1) {
                    sum++;
                    max = Math.max(max, sum);
                }
                return current;
            }, 0);
            return max;
        }

        const res = findMaxConsecutiveOnes([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
        console.log(res);

    })();
</script>
<p>492. 构造矩形，作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 1.
    你设计的矩形页面必须等于给定的目标面积。 2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。 3. 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。</p>
<script data-msg="492. 构造矩形，作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 1. 你设计的矩形页面必须等于给定的目标面积。 2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。 3. 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。">
    (() => {
        return;
        //  给定的面积不大于 10,000,000 且为正整数。
        // 你设计的页面的长度和宽度必须都是正整数
        function constructRectangle(area){
            const sqrt = Math.sqrt(area);
            //  是正方形
            if (sqrt % 1 === 0) {
                return [sqrt, sqrt];
            }
            let w = Math.floor(sqrt);
            let l = 0;
            while (w > 1) {
                l = area / w;
                if (l % 1 === 0) {
                    return [w, l];
                }
                w--;
            }
            return [1, area];
        }

        const res = constructRectangle(1602);
        console.log(res);
    })();
</script>
<p>496. 下一个更大元素 I，给定两个 没有重复元素 的数组 nums1
    和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出
    -1 。</p>
<script data-msg="496. 下一个更大元素 I，给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。">
    (() => {
        // return;
        //  暴力法
        // function nextGreaterElement(nums1, nums2){
        //     const res = new Array(nums1.length);
        //     nums1.forEach((item, i) => {
        //         const index = nums2.indexOf(item);
        //         const greatThan = nums2.slice(index).find(_item => {
        //             return _item > item;
        //         });
        //         if (!greatThan) {
        //             res[i] = -1;
        //             return;
        //         }
        //         res[i] = greatThan;
        //     });
        //     return res;
        // }

        return;

        //  hash 法
        function nextGreaterElement(nums1, nums2){
            console.log(nums1);
            console.log(nums2);
            const hash = {};
            nums2.forEach((item, index) => {
                hash[item] = -1;
                //  剩余的数组
                const reArr = nums2.slice(index + 1);
                //  之后第一个大的index
                let _index = reArr.find(_item => {
                    return _item > item;
                });
                //  如果没有
                if (_index === undefined) {
                    return;
                }
                hash[item] = _index;
            });
            console.log(hash);
            const arr = new Array(nums1.length);
            // debugger
            nums1.forEach((item, index) => {
                arr[index] = hash[item];
            });
            return arr;
        }

        const nums1 = [4, 1, 2];
        const nums2 = [1, 3, 4, 2];
        //
        // const nums1 = [2, 4];
        // const nums2 = [1, 2, 3, 4];

        const res = nextGreaterElement(nums1, nums2);
        console.log(res);
    })();
</script>
<p>500. 键盘行，给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</p>
<script data-msg="500. 键盘行，给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。">
    (() => {
        //  略
    })();
</script>
<p class="red">501. 二叉搜索树中的众数，给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST
    有如下定义：，结点左子树中所含结点的值小于等于当前结点的值，结点右子树中所含结点的值大于等于当前结点的值，左子树和右子树都是二叉搜索树</p>
<script data-msg=">501. 二叉搜索树中的众数，给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义：，结点左子树中所含结点的值小于等于当前结点的值，结点右子树中所含结点的值大于等于当前结点的值，左子树和右子树都是二叉搜索树">
    (() => {
        //  中序遍历，然后就是一个有序数组了，不需要额外的空间，中序遍历难，那就快排递归
        function findMode(root){
            console.log(root);
            root = quickSort(root);
            console.log(root);
            let max = 0;
            let item = null;
            let sum = 0;
            
            for (let i = 0; i < root.length; i++) {
                if (root[i] === item) {
                    sum++;
                    if (sum >= max) {
                        max = sum;
                    }
                    continue;
                }
                item = root[i];
                sum = 1;
            }
            return max;
        }

        function quickSort(arr){
            if (arr.length <= 1) {
                return arr;
            }
            let left = [];
            let right = [];
            let middleArr = [];
            let middle = Math.floor(arr.length / 2);
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] < arr[middle]) {
                    left.push(arr[i]);
                } else if (arr[i] > arr[middle]) {
                    right.push(arr[i]);
                } else {
                    middleArr.push(arr[i]);
                }
            }
            return quickSort(left).concat(middleArr).concat(quickSort(right));
        }

        const res = findMode([1, null, 2, 2]);
        console.log(res);
    })();
</script>
</body>
</html>





















